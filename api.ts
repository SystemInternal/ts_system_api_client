/* tslint:disable */
/* eslint-disable */
/**
 * System REST API
 * This is a REST API through which clients can interact with System - an **open**, **collaborative**, and **ever-growing knowledge base** of all the world\'s systems. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Add subscription seat input.
 * @export
 * @interface AddSubscriptionSeatIn
 */
export interface AddSubscriptionSeatIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddSubscriptionSeatIn
     */
    'emails': Array<string>;
}
/**
 * List of algorithms model.
 * @export
 * @interface AlgorithmListResult
 */
export interface AlgorithmListResult {
    /**
     * 
     * @type {Array<AlgorithmOut>}
     * @memberof AlgorithmListResult
     */
    'items': Array<AlgorithmOut>;
}
/**
 * Algorithm output model.
 * @export
 * @interface AlgorithmOut
 */
export interface AlgorithmOut {
    /**
     * 
     * @type {string}
     * @memberof AlgorithmOut
     */
    'algorithm_id': string;
    /**
     * 
     * @type {string}
     * @memberof AlgorithmOut
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof AlgorithmOut
     */
    'description': string;
}
/**
 * Interface for finding in study.
 * @export
 * @interface AppSchemaFindingsFinding
 */
export interface AppSchemaFindingsFinding {
    /**
     * 
     * @type {string}
     * @memberof AppSchemaFindingsFinding
     */
    'summary'?: string;
    /**
     * 
     * @type {RawFinding}
     * @memberof AppSchemaFindingsFinding
     */
    'data'?: RawFinding;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppSchemaFindingsFinding
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AppSchemaFindingsFinding
     */
    'mechanistic': boolean;
    /**
     * 
     * @type {string}
     * @memberof AppSchemaFindingsFinding
     */
    'mechanism_type'?: string;
}
/**
 * Interface for Groundings for a specific namespace.
 * @export
 * @interface AppSchemaGroundingsGrounding
 */
export interface AppSchemaGroundingsGrounding {
    /**
     * 
     * @type {string}
     * @memberof AppSchemaGroundingsGrounding
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppSchemaGroundingsGrounding
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppSchemaGroundingsGrounding
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof AppSchemaGroundingsGrounding
     */
    'namespace_id_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppSchemaGroundingsGrounding
     */
    'definition'?: string;
}
/**
 * Author output.
 * @export
 * @interface AuthorRDBOut
 */
export interface AuthorRDBOut {
    /**
     * 
     * @type {string}
     * @memberof AuthorRDBOut
     */
    'full_name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorRDBOut
     */
    'openalex_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorRDBOut
     */
    'orcid'?: string;
}
/**
 * Credentials for an integration without password.
 * @export
 * @interface BigQueryCredentials
 */
export interface BigQueryCredentials {
    /**
     * Integration location.
     * @type {string}
     * @memberof BigQueryCredentials
     */
    'location': string;
    /**
     * Integration project.
     * @type {string}
     * @memberof BigQueryCredentials
     */
    'project': string;
}
/**
 * Input credentials for a BigQuery integration.
 * @export
 * @interface BigQueryCredentialsIn
 */
export interface BigQueryCredentialsIn {
    /**
     * Integration location.
     * @type {string}
     * @memberof BigQueryCredentialsIn
     */
    'location': string;
    /**
     * Integration project.
     * @type {string}
     * @memberof BigQueryCredentialsIn
     */
    'project': string;
    /**
     * Integration credentials.
     * @type {string}
     * @memberof BigQueryCredentialsIn
     */
    'raw_credentials': string;
}
/**
 * Cluster out model.
 * @export
 * @interface ClusterOut
 */
export interface ClusterOut {
    /**
     * 
     * @type {Array<ScoredCluster>}
     * @memberof ClusterOut
     */
    'clusters': Array<ScoredCluster>;
    /**
     * 
     * @type {Array<ClusteredRelationship>}
     * @memberof ClusterOut
     */
    'relationships': Array<ClusteredRelationship>;
    /**
     * 
     * @type {string}
     * @memberof ClusterOut
     */
    'cache_key'?: string;
}
/**
 * Cluster out status model.
 * @export
 * @interface ClusterOutStatus
 */
export interface ClusterOutStatus {
    /**
     * 
     * @type {FunctionStatus}
     * @memberof ClusterOutStatus
     */
    'status': FunctionStatus;
    /**
     * 
     * @type {SynthesisResponse}
     * @memberof ClusterOutStatus
     */
    'cluster_out'?: SynthesisResponse;
}
/**
 * Clustered evidence metadata.  # noqa: E501
 * @export
 * @interface ClusteredEvidenceMetadata
 */
export interface ClusteredEvidenceMetadata {
    /**
     * 
     * @type {number}
     * @memberof ClusteredEvidenceMetadata
     */
    'citation_count_min'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusteredEvidenceMetadata
     */
    'citation_count_max'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusteredEvidenceMetadata
     */
    'publish_date_earliest'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusteredEvidenceMetadata
     */
    'publish_date_latest'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusteredEvidenceMetadata
     */
    'evidence_count'?: number;
}
/**
 * Schema for clustered relationship response.
 * @export
 * @interface ClusteredRelationship
 */
export interface ClusteredRelationship {
    /**
     * 
     * @type {Array<GroundedVariable>}
     * @memberof ClusteredRelationship
     */
    'variables': Array<GroundedVariable>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusteredRelationship
     */
    'cluster_ids': Array<string>;
    /**
     * 
     * @type {Array<FindingMeta>}
     * @memberof ClusteredRelationship
     */
    'finding_metas': Array<FindingMeta>;
    /**
     * 
     * @type {Array<StudyFindings>}
     * @memberof ClusteredRelationship
     */
    'findings'?: Array<StudyFindings>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum ClusteringMethods {
    Agglomerative = 'agglomerative',
    Dbscan = 'dbscan',
    Paraphrase = 'paraphrase'
}

/**
 * Concept resource links.
 * @export
 * @interface ConceptLinks
 */
export interface ConceptLinks {
    /**
     * Link to this resource.
     * @type {string}
     * @memberof ConceptLinks
     */
    'self': string;
}
/**
 * Concept output model.
 * @export
 * @interface ConceptOut
 */
export interface ConceptOut {
    /**
     * 
     * @type {string}
     * @memberof ConceptOut
     */
    'id': string;
    /**
     * User who created this resource.
     * @type {string}
     * @memberof ConceptOut
     */
    'created_by'?: string;
    /**
     * Time when resource was created.
     * @type {string}
     * @memberof ConceptOut
     */
    'created_at'?: string;
    /**
     * User who made the last edit.
     * @type {string}
     * @memberof ConceptOut
     */
    'last_updated_by'?: string;
    /**
     * Time of last edit.
     * @type {string}
     * @memberof ConceptOut
     */
    'last_updated_at'?: string;
    /**
     * 
     * @type {Array<ResourceAction>}
     * @memberof ConceptOut
     */
    '_permissions'?: Array<ResourceAction>;
    /**
     * Flags on this resource.
     * @type {Array<ResourceFlag>}
     * @memberof ConceptOut
     */
    'flags'?: Array<ResourceFlag>;
    /**
     * Tags to attach to resource (max 64).
     * @type {Array<string>}
     * @memberof ConceptOut
     */
    'tags'?: Array<string>;
    /**
     * Search terms to attach to resource (max 64).
     * @type {Array<string>}
     * @memberof ConceptOut
     */
    'search_terms'?: Array<string>;
    /**
     * A hidden object is not meant to be shown on the frontend.
     * @type {boolean}
     * @memberof ConceptOut
     */
    'is_hidden'?: boolean;
    /**
     * Notes whether the resource is private or not
     * @type {boolean}
     * @memberof ConceptOut
     */
    'is_private'?: boolean;
    /**
     * Notes whether the resource is private or not
     * @type {boolean}
     * @memberof ConceptOut
     * @deprecated
     */
    '_private'?: boolean;
    /**
     * The Concept\'s corresponding wikidata id.
     * @type {string}
     * @memberof ConceptOut
     */
    'wikidata_id': string;
    /**
     * Preferred name if different from existing.
     * @type {string}
     * @memberof ConceptOut
     */
    'preferred_name'?: string;
    /**
     * The Concept\'s name.
     * @type {string}
     * @memberof ConceptOut
     */
    'name'?: string;
    /**
     * The Concept\'s aliases.
     * @type {Array<string>}
     * @memberof ConceptOut
     */
    'aliases'?: Array<string>;
    /**
     * The Concept\'s semantic types.
     * @type {Array<string>}
     * @memberof ConceptOut
     */
    'semantic_types'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConceptOut
     */
    'description'?: string;
    /**
     * Collection of links to related resources.
     * @type {ConceptLinks}
     * @memberof ConceptOut
     */
    '_links'?: ConceptLinks;
}
/**
 * Concept pagination out.
 * @export
 * @interface ConceptPaginationOut
 */
export interface ConceptPaginationOut {
    /**
     * Collection of links to related resources.
     * @type {FirstLastPaginationLinks}
     * @memberof ConceptPaginationOut
     */
    '_links'?: FirstLastPaginationLinks;
    /**
     * List of results.
     * @type {Array<ConceptOut>}
     * @memberof ConceptPaginationOut
     */
    'items'?: Array<ConceptOut>;
    /**
     * List of ids.
     * @type {Array<string>}
     * @memberof ConceptPaginationOut
     */
    'ids'?: Array<string>;
    /**
     * Total number of results available.
     * @type {number}
     * @memberof ConceptPaginationOut
     */
    'total'?: number;
    /**
     * Valid \'order_by\' values that can be applied to current pagination set.
     * @type {Array<string>}
     * @memberof ConceptPaginationOut
     */
    '_sorts'?: Array<string>;
}
/**
 * Node at end of concept relationship.
 * @export
 * @interface ConceptRelationshipNode
 */
export interface ConceptRelationshipNode {
    /**
     * 
     * @type {string}
     * @memberof ConceptRelationshipNode
     */
    'system_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConceptRelationshipNode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConceptRelationshipNode
     */
    'wikidata_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConceptRelationshipNode
     */
    'supporting_association_ids': Array<string>;
}
/**
 * Concept relationships model.
 * @export
 * @interface ConceptRelationshipsOut
 */
export interface ConceptRelationshipsOut {
    /**
     * 
     * @type {ConceptOut}
     * @memberof ConceptRelationshipsOut
     */
    'concept': ConceptOut;
    /**
     * 
     * @type {Array<ConceptRelationshipNode>}
     * @memberof ConceptRelationshipsOut
     */
    'upstream': Array<ConceptRelationshipNode>;
    /**
     * 
     * @type {Array<ConceptRelationshipNode>}
     * @memberof ConceptRelationshipsOut
     */
    'downstream': Array<ConceptRelationshipNode>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum ConceptSortEnum {
    CreatedAt = 'created_at',
    LastUpdatedAt = 'last_updated_at',
    Name = 'name'
}

/**
 * Confidence interval output model.
 * @export
 * @interface ConfidenceIntervalOut
 */
export interface ConfidenceIntervalOut {
    /**
     * Confidence level for interval.
     * @type {SignificanceLevel}
     * @memberof ConfidenceIntervalOut
     */
    'level'?: SignificanceLevel;
    /**
     * The lower bound of the CI.
     * @type {number}
     * @memberof ConfidenceIntervalOut
     */
    'ci_lower'?: number;
    /**
     * The upper bound of the CI.
     * @type {number}
     * @memberof ConfidenceIntervalOut
     */
    'ci_upper'?: number;
}
/**
 * An Enterprise Resource.
 * @export
 * @interface Enterprise
 */
export interface Enterprise {
    /**
     * Enterprise name.
     * @type {string}
     * @memberof Enterprise
     */
    'name': string;
    /**
     * Enterprise Identity Provider.
     * @type {string}
     * @memberof Enterprise
     */
    'identity_provider'?: string;
    /**
     * Enterprise SAML SSO entity id.
     * @type {string}
     * @memberof Enterprise
     */
    'entity_id'?: string;
    /**
     * Enterprise SAML SSO ACS url.
     * @type {string}
     * @memberof Enterprise
     */
    'acs_url'?: string;
    /**
     * Enterprise SAML SSO IDP metadata
     * @type {string}
     * @memberof Enterprise
     */
    'idp_metadata'?: string;
    /**
     * 
     * @type {number}
     * @memberof Enterprise
     */
    'id': number;
    /**
     * The list of integrations to retrieve
     * @type {Array<Integration>}
     * @memberof Enterprise
     */
    'integrations'?: Array<Integration>;
    /**
     * The enterprise messages
     * @type {Array<MessageOut>}
     * @memberof Enterprise
     */
    'messages'?: Array<MessageOut>;
    /**
     * The actions the requesting user is allowed to perform on this resource.
     * @type {Array<ResourceAction>}
     * @memberof Enterprise
     */
    '_permissions'?: Array<ResourceAction>;
}
/**
 * An Enterprise create/update Resource.
 * @export
 * @interface EnterpriseIn
 */
export interface EnterpriseIn {
    /**
     * Enterprise name.
     * @type {string}
     * @memberof EnterpriseIn
     */
    'name': string;
    /**
     * Enterprise Identity Provider.
     * @type {string}
     * @memberof EnterpriseIn
     */
    'identity_provider'?: string;
    /**
     * Enterprise SAML SSO entity id.
     * @type {string}
     * @memberof EnterpriseIn
     */
    'entity_id'?: string;
    /**
     * Enterprise SAML SSO ACS url.
     * @type {string}
     * @memberof EnterpriseIn
     */
    'acs_url'?: string;
    /**
     * Enterprise SAML SSO IDP metadata
     * @type {string}
     * @memberof EnterpriseIn
     */
    'idp_metadata'?: string;
}
/**
 * Evidence category.
 * @export
 * @enum {string}
 */

export enum EvidenceCategory {
    Statistical = 'statistical',
    Mechanistic = 'mechanistic'
}

/**
 * Evidence output.
 * @export
 * @interface EvidenceRDBOut
 */
export interface EvidenceRDBOut {
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'system_id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'study_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'statement_id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'source_hash': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'mechanism_type': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'variable_1_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'variable_1_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'concept_1_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'variable_2_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'variable_2_name': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'concept_2_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'source_api'?: string;
    /**
     * 
     * @type {number}
     * @memberof EvidenceRDBOut
     */
    'pubmed_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'source_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRDBOut
     */
    'evidence_raw_text'?: string;
}
/**
 * Edge Typed Link model.  # noqa: E501
 * @export
 * @interface ExtendedLinkObject
 */
export interface ExtendedLinkObject {
    /**
     * 
     * @type {string}
     * @memberof ExtendedLinkObject
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedLinkObject
     */
    'target': string;
    /**
     * 
     * @type {GraphLinkType}
     * @memberof ExtendedLinkObject
     */
    'edge_type'?: GraphLinkType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtendedLinkObject
     */
    'association_ids'?: Array<string>;
}
/**
 * Object Typed Node model.  # noqa: E501
 * @export
 * @interface ExtendedNodeObject
 */
export interface ExtendedNodeObject {
    /**
     * 
     * @type {string}
     * @memberof ExtendedNodeObject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedNodeObject
     */
    'name': string;
    /**
     * 
     * @type {GraphNodeType}
     * @memberof ExtendedNodeObject
     */
    'object_type'?: GraphNodeType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtendedNodeObject
     */
    'system_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtendedNodeObject
     */
    'tags'?: Array<string>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum FeatureContributionMethod {
    Gini = 'gini',
    Gain = 'gain',
    Shap = 'shap',
    Coefficient = 'coefficient',
    Lime = 'lime',
    Permutation = 'permutation',
    PearsonR = 'pearson_r',
    KendallTau = 'kendall_tau',
    CramerV = 'cramer_v',
    KruskalWallisHTest = 'kruskal_wallis_h_test',
    ControlVariable = 'control_variable',
    ProductMomentR = 'product_moment_r',
    FrequencyScore = 'frequency_score',
    OddsRatio = 'odds_ratio',
    RelativeRiskRatio = 'relative_risk_ratio',
    HazardRatio = 'hazard_ratio',
    MeanGainUnstandardized = 'mean_gain_unstandardized',
    MeanGainStandardized = 'mean_gain_standardized',
    MeanDifferenceUnstandardized = 'mean_difference_unstandardized',
    MeanDifferenceStandardized = 'mean_difference_standardized',
    ProportionDifference = 'proportion_difference',
    LogOddsRatio = 'log_odds_ratio',
    PearsonChiSquaredTest = 'pearson_chi_squared_test',
    Forecast = 'forecast',
    PercentChangeDifference = 'percent_change_difference',
    AdjustedOddsRatio = 'adjusted_odds_ratio',
    AdjustedHazardRatio = 'adjusted_hazard_ratio',
    IncidentRateRatio = 'incident_rate_ratio',
    RiskDifference = 'risk_difference',
    InformationFlow = 'information_flow',
    StandardizedCoefficient = 'standardized_coefficient',
    CohensD = 'cohens_d',
    HedgesG = 'hedges_g',
    GlassSDelta = 'glass_s_delta',
    RootMeanSquareDifferencePsi = 'root_mean_square_difference_psi',
    MahalanobisDistance = 'mahalanobis_distance',
    CohensW = 'cohens_w',
    CohensH = 'cohens_h',
    CliffsDelta = 'cliffs_delta',
    RankBiserialCorrelation = 'rank_biserial_correlation',
    SpearmanCorrelation = 'spearman_correlation',
    Elasticity = 'elasticity',
    PrevalenceRatio = 'prevalence_ratio',
    Invalid = 'invalid'
}

/**
 * Feedback on a finding.
 * @export
 * @interface FindingFeedbackIn
 */
export interface FindingFeedbackIn {
    /**
     * 
     * @type {string}
     * @memberof FindingFeedbackIn
     */
    'feedback_type': string;
    /**
     * 
     * @type {object}
     * @memberof FindingFeedbackIn
     */
    'user_comments'?: object;
}
/**
 * Schema for identifying finding.
 * @export
 * @interface FindingMeta
 */
export interface FindingMeta {
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'pmid'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'doi'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'association_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'publish_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof FindingMeta
     */
    'article_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingMeta
     */
    'citation_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'name'?: string;
    /**
     * 
     * @type {Array<StudyAuthor>}
     * @memberof FindingMeta
     */
    'authorships'?: Array<StudyAuthor>;
    /**
     * 
     * @type {string}
     * @memberof FindingMeta
     */
    'journal'?: string;
}
/**
 * Findings Log Out.  # noqa: E501
 * @export
 * @interface FindingsLogOut
 */
export interface FindingsLogOut {
    /**
     * 
     * @type {Study}
     * @memberof FindingsLogOut
     */
    'study'?: Study;
    /**
     * 
     * @type {Array<SohServiceClientModelsFindingFinding>}
     * @memberof FindingsLogOut
     */
    'findings': Array<SohServiceClientModelsFindingFinding>;
}
/**
 * Next/prev Pagination links with first and last urls.
 * @export
 * @interface FirstLastPaginationLinks
 */
export interface FirstLastPaginationLinks {
    /**
     * Link to this resource.
     * @type {string}
     * @memberof FirstLastPaginationLinks
     */
    'self': string;
    /**
     * Link to next page.
     * @type {string}
     * @memberof FirstLastPaginationLinks
     */
    'next'?: string;
    /**
     * Link to previous page.
     * @type {string}
     * @memberof FirstLastPaginationLinks
     */
    'prev'?: string;
    /**
     * Link to first page.
     * @type {string}
     * @memberof FirstLastPaginationLinks
     */
    'first'?: string;
    /**
     * Link to last page.
     * @type {string}
     * @memberof FirstLastPaginationLinks
     */
    'last'?: string;
}
/**
 * Status for polling functions.
 * @export
 * @enum {string}
 */

export enum FunctionStatus {
    Pending = 'pending',
    Running = 'running',
    Finished = 'finished',
    Error = 'error'
}

/**
 * Document model.
 * @export
 * @interface GetFTRDocument
 */
export interface GetFTRDocument {
    /**
     * 
     * @type {string}
     * @memberof GetFTRDocument
     */
    'contentType': string;
    /**
     * 
     * @type {string}
     * @memberof GetFTRDocument
     */
    'url': string;
}
/**
 * Entitlement model.
 * @export
 * @interface GetFTREntitlement
 */
export interface GetFTREntitlement {
    /**
     * 
     * @type {string}
     * @memberof GetFTREntitlement
     */
    'doi': string;
    /**
     * 
     * @type {number}
     * @memberof GetFTREntitlement
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof GetFTREntitlement
     */
    'entitled'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFTREntitlement
     */
    'accessType'?: string;
    /**
     * 
     * @type {GetFTROrganization}
     * @memberof GetFTREntitlement
     */
    'org'?: GetFTROrganization;
    /**
     * 
     * @type {Array<GetFTRDocument>}
     * @memberof GetFTREntitlement
     */
    'vor'?: Array<GetFTRDocument>;
    /**
     * 
     * @type {Array<GetFTRDocument>}
     * @memberof GetFTREntitlement
     */
    'av'?: Array<GetFTRDocument>;
    /**
     * 
     * @type {string}
     * @memberof GetFTREntitlement
     */
    'document'?: string;
}
/**
 * Entitlements input model.
 * @export
 * @interface GetFTREntitlementsIn
 */
export interface GetFTREntitlementsIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetFTREntitlementsIn
     */
    'dois': Array<string>;
    /**
     * 
     * @type {GetFTROrganization}
     * @memberof GetFTREntitlementsIn
     */
    'org'?: GetFTROrganization;
}
/**
 * Entitlements output model.
 * @export
 * @interface GetFTREntitlementsOut
 */
export interface GetFTREntitlementsOut {
    /**
     * 
     * @type {Array<GetFTREntitlement>}
     * @memberof GetFTREntitlementsOut
     */
    'entitlements': Array<GetFTREntitlement>;
}
/**
 * Organization model.
 * @export
 * @interface GetFTROrganization
 */
export interface GetFTROrganization {
    /**
     * 
     * @type {string}
     * @memberof GetFTROrganization
     */
    'ipv4'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFTROrganization
     */
    'entityID'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFTROrganization
     */
    'ringgoldID'?: string;
}
/**
 * Graph Data model.  # noqa: E501
 * @export
 * @interface GraphData
 */
export interface GraphData {
    /**
     * Nodes of graph data.
     * @type {Array<ExtendedNodeObject>}
     * @memberof GraphData
     */
    'nodes': Array<ExtendedNodeObject>;
    /**
     * Links of graph data.
     * @type {Array<ExtendedLinkObject>}
     * @memberof GraphData
     */
    'links': Array<ExtendedLinkObject>;
}
/**
 * Graph Link Type enum.
 * @export
 * @enum {string}
 */

export enum GraphLinkType {
    DatasetRelationship = 'dataset_relationship',
    ConceptRelationship = 'concept_relationship',
    VariableRelationship = 'variable_relationship',
    FeatureRelationship = 'feature_relationship',
    FeatureVariable = 'feature_variable',
    Measures = 'measures'
}

/**
 * Graph metrics schema.
 * @export
 * @interface GraphMetrics
 */
export interface GraphMetrics {
    /**
     * 
     * @type {number}
     * @memberof GraphMetrics
     */
    'num_relationships': number;
    /**
     * 
     * @type {number}
     * @memberof GraphMetrics
     */
    'num_topics': number;
    /**
     * 
     * @type {number}
     * @memberof GraphMetrics
     */
    'num_sources': number;
    /**
     * 
     * @type {number}
     * @memberof GraphMetrics
     */
    'num_findings': number;
    /**
     * 
     * @type {string}
     * @memberof GraphMetrics
     */
    'last_updated': string;
}
/**
 * Graph Node Type enum.
 * @export
 * @enum {string}
 */

export enum GraphNodeType {
    Dataset = 'dataset',
    Concept = 'concept',
    Variable = 'variable',
    Feature = 'feature'
}

/**
 * Graph out.  # noqa: E501
 * @export
 * @interface GraphOut
 */
export interface GraphOut {
    /**
     * 
     * @type {Array<SohServiceClientModelsTopicNodeTopicNode>}
     * @memberof GraphOut
     */
    'nodes': Array<SohServiceClientModelsTopicNodeTopicNode>;
    /**
     * 
     * @type {Array<TopicEdge>}
     * @memberof GraphOut
     */
    'links': Array<TopicEdge>;
    /**
     * 
     * @type {number}
     * @memberof GraphOut
     */
    'original_link_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphOut
     */
    'original_node_count'?: number;
}
/**
 * GraphQL query model.
 * @export
 * @interface GraphQLQuery
 */
export interface GraphQLQuery {
    /**
     * 
     * @type {string}
     * @memberof GraphQLQuery
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof GraphQLQuery
     */
    'operationName'?: string;
    /**
     * 
     * @type {any}
     * @memberof GraphQLQuery
     */
    'variables'?: any;
}
/**
 * Graph time series out.  # noqa: E501
 * @export
 * @interface GraphTimeSeriesOut
 */
export interface GraphTimeSeriesOut {
    /**
     * 
     * @type {Array<TimeSeriesDataPoint>}
     * @memberof GraphTimeSeriesOut
     */
    'num_findings_time_series': Array<TimeSeriesDataPoint>;
    /**
     * 
     * @type {Array<TimeSeriesDataPoint>}
     * @memberof GraphTimeSeriesOut
     */
    'num_relationships_time_series': Array<TimeSeriesDataPoint>;
    /**
     * 
     * @type {Array<TimeSeriesDataPoint>}
     * @memberof GraphTimeSeriesOut
     */
    'num_concepts_time_series': Array<TimeSeriesDataPoint>;
}
/**
 * 
 * @export
 * @interface GroundedEntity
 */
export interface GroundedEntity {
    /**
     * 
     * @type {string}
     * @memberof GroundedEntity
     */
    'name': string;
    /**
     * 
     * @type {Array<QueryParserApiModelsPydanticGrounding>}
     * @memberof GroundedEntity
     */
    'groundings'?: Array<QueryParserApiModelsPydanticGrounding>;
}
/**
 * Variable object schema for relationships.
 * @export
 * @interface GroundedVariable
 */
export interface GroundedVariable {
    /**
     * 
     * @type {string}
     * @memberof GroundedVariable
     */
    'system_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroundedVariable
     */
    'name': string;
    /**
     * 
     * @type {Array<VariableGrounding>}
     * @memberof GroundedVariable
     */
    'groundings'?: Array<VariableGrounding>;
    /**
     * 
     * @type {string}
     * @memberof GroundedVariable
     */
    'topic_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroundedVariable
     */
    'topic_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroundedVariable
     */
    'topic_wikidata_id'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * SSO Identity Providers preconfigured in AWS Cognito user pool.
 * @export
 * @enum {string}
 */

export enum IdentityProvider {
    Google = 'Google',
    KeycloakGoogleDev = 'keycloak-google-dev'
}

/**
 * Get Identity Provider Name.
 * @export
 * @interface IdentityProviderNameOut
 */
export interface IdentityProviderNameOut {
    /**
     * Name of the identity provider for given email as configured in System
     * @type {IdentityProvider}
     * @memberof IdentityProviderNameOut
     */
    'idp'?: IdentityProvider;
}
/**
 * An Integration Resource.
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * Integration name.
     * @type {string}
     * @memberof Integration
     */
    'name'?: string;
    /**
     * Integration state.
     * @type {IntegrationState}
     * @memberof Integration
     */
    'state'?: IntegrationState;
    /**
     * The integration type.
     * @type {IntegrationType}
     * @memberof Integration
     */
    'service_type': IntegrationType;
    /**
     * API Endpoint.
     * @type {string}
     * @memberof Integration
     */
    'endpoint': string;
    /**
     * Integration IP address.
     * @type {string}
     * @memberof Integration
     */
    'ip_address'?: string;
    /**
     * Integration lamdba names.
     * @type {string}
     * @memberof Integration
     */
    'lambda_arn'?: string;
    /**
     * Is this integration deployed on enterprise\'s internal stack?
     * @type {boolean}
     * @memberof Integration
     */
    'on_premise'?: boolean;
    /**
     * The list of tables to retrieve
     * @type {Array<Table>}
     * @memberof Integration
     */
    'tables'?: Array<Table>;
    /**
     * The list of views to retrieve
     * @type {Array<Table>}
     * @memberof Integration
     */
    'views'?: Array<Table>;
    /**
     * The integration messages
     * @type {Array<MessageOut>}
     * @memberof Integration
     */
    'messages'?: Array<MessageOut>;
    /**
     * 
     * @type {number}
     * @memberof Integration
     */
    'id': number;
    /**
     * Integration credentials.
     * @type {RedshiftCredentials | SnowflakeCredentials | BigQueryCredentials | LookerCredentials | ModeCredentials}
     * @memberof Integration
     */
    'credentials': RedshiftCredentials | SnowflakeCredentials | BigQueryCredentials | LookerCredentials | ModeCredentials;
    /**
     * Enterprise link.
     * @type {string}
     * @memberof Integration
     */
    'enterprise'?: string;
    /**
     * Team link.
     * @type {string}
     * @memberof Integration
     */
    'team'?: string;
    /**
     * The actions the requesting user is allowed to perform on this resource.
     * @type {Array<ResourceAction>}
     * @memberof Integration
     */
    '_permissions'?: Array<ResourceAction>;
}
/**
 * Integration model for create/update.
 * @export
 * @interface IntegrationIn
 */
export interface IntegrationIn {
    /**
     * Integration name.
     * @type {string}
     * @memberof IntegrationIn
     */
    'name'?: string;
    /**
     * Integration state.
     * @type {IntegrationState}
     * @memberof IntegrationIn
     */
    'state'?: IntegrationState;
    /**
     * The integration type.
     * @type {IntegrationType}
     * @memberof IntegrationIn
     */
    'service_type'?: IntegrationType;
    /**
     * API Endpoint.
     * @type {string}
     * @memberof IntegrationIn
     */
    'endpoint'?: string;
    /**
     * Integration IP address.
     * @type {string}
     * @memberof IntegrationIn
     */
    'ip_address'?: string;
    /**
     * Integration lamdba names.
     * @type {string}
     * @memberof IntegrationIn
     */
    'lambda_arn'?: string;
    /**
     * Is this integration deployed on enterprise\'s internal stack?
     * @type {boolean}
     * @memberof IntegrationIn
     */
    'on_premise'?: boolean;
    /**
     * The list of tables to retrieve
     * @type {Array<Table>}
     * @memberof IntegrationIn
     */
    'tables'?: Array<Table>;
    /**
     * The list of views to retrieve
     * @type {Array<Table>}
     * @memberof IntegrationIn
     */
    'views'?: Array<Table>;
    /**
     * The integration messages
     * @type {Array<MessageOut>}
     * @memberof IntegrationIn
     */
    'messages'?: Array<MessageOut>;
    /**
     * Integration credentials.
     * @type {RedshiftCredentialsIn | SnowflakeCredentialsIn | BigQueryCredentialsIn | LookerCredentialsIn | ModeCredentialsIn}
     * @memberof IntegrationIn
     */
    'credentials'?: RedshiftCredentialsIn | SnowflakeCredentialsIn | BigQueryCredentialsIn | LookerCredentialsIn | ModeCredentialsIn;
    /**
     * Team or Enterprise link
     * @type {string}
     * @memberof IntegrationIn
     */
    'owner'?: string;
}
/**
 * Integration service state.
 * @export
 * @enum {string}
 */

export enum IntegrationState {
    Initial = 'INITIAL',
    Active = 'ACTIVE',
    Inactive = 'INACTIVE'
}

/**
 * Integration retrieval types.
 * @export
 * @enum {string}
 */

export enum IntegrationType {
    Redshift = 'REDSHIFT',
    Snowflake = 'SNOWFLAKE',
    Bigquery = 'BIGQUERY',
    Looker = 'LOOKER',
    Mode = 'MODE'
}

/**
 * Credentials for a Looker integration without password.
 * @export
 * @interface LookerCredentials
 */
export interface LookerCredentials {
    /**
     * Integration verify ssl
     * @type {boolean}
     * @memberof LookerCredentials
     */
    'verify_ssl'?: boolean;
    /**
     * Integration base url
     * @type {string}
     * @memberof LookerCredentials
     */
    'base_url': string;
}
/**
 * Input credentials for a Looker integration.
 * @export
 * @interface LookerCredentialsIn
 */
export interface LookerCredentialsIn {
    /**
     * Integration verify ssl
     * @type {boolean}
     * @memberof LookerCredentialsIn
     */
    'verify_ssl'?: boolean;
    /**
     * Integration base url
     * @type {string}
     * @memberof LookerCredentialsIn
     */
    'base_url': string;
    /**
     * Integration client id.
     * @type {string}
     * @memberof LookerCredentialsIn
     */
    'client_id': string;
    /**
     * Integration client secret key.
     * @type {string}
     * @memberof LookerCredentialsIn
     */
    'client_secret': string;
}
/**
 * Path.  # noqa: E501
 * @export
 * @interface MapPath
 */
export interface MapPath {
    /**
     * Sorted list of edge IDs
     * @type {Array<string>}
     * @memberof MapPath
     */
    'edge_ids': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MapPath
     */
    'evidence_count': number;
}
/**
 * Map paths out.  # noqa: E501
 * @export
 * @interface MapPathsOut
 */
export interface MapPathsOut {
    /**
     * 
     * @type {number}
     * @memberof MapPathsOut
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof MapPathsOut
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof MapPathsOut
     */
    'total': number;
    /**
     * 
     * @type {Array<SystemGraphApiClientModelsTopicNodeTopicNode>}
     * @memberof MapPathsOut
     */
    'nodes': Array<SystemGraphApiClientModelsTopicNodeTopicNode>;
    /**
     * 
     * @type {Array<MapRelationship>}
     * @memberof MapPathsOut
     */
    'links': Array<MapRelationship>;
    /**
     * 
     * @type {Array<MapPath>}
     * @memberof MapPathsOut
     */
    'paths': Array<MapPath>;
}
/**
 * Map relationship.  # noqa: E501
 * @export
 * @interface MapRelationship
 */
export interface MapRelationship {
    /**
     * 
     * @type {string}
     * @memberof MapRelationship
     */
    'edge_id': string;
    /**
     * 
     * @type {string}
     * @memberof MapRelationship
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof MapRelationship
     */
    'target': string;
    /**
     * Association IDs
     * @type {Array<string>}
     * @memberof MapRelationship
     */
    'association_ids'?: Array<string>;
    /**
     * Evidence IDs
     * @type {Array<string>}
     * @memberof MapRelationship
     */
    'evidence_ids'?: Array<string>;
}
/**
 * Metadata for mechanistic finding.
 * @export
 * @interface MechanisticMetadata
 */
export interface MechanisticMetadata {
    /**
     * 
     * @type {Array<GroundedVariable>}
     * @memberof MechanisticMetadata
     */
    'variables': Array<GroundedVariable>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MechanisticMetadata
     */
    'populations'?: Array<string>;
    /**
     * 
     * @type {StudyMetadataRDB}
     * @memberof MechanisticMetadata
     */
    'study_metadata'?: StudyMetadataRDB;
    /**
     * 
     * @type {string}
     * @memberof MechanisticMetadata
     */
    'mechanism_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MechanisticMetadata
     */
    'source_statement'?: string;
}
/**
 * Mechanistic relationship model.
 * @export
 * @interface MechanisticRelationship
 */
export interface MechanisticRelationship {
    /**
     * 
     * @type {string}
     * @memberof MechanisticRelationship
     */
    'id': string;
    /**
     * 
     * @type {MechanisticMetadata}
     * @memberof MechanisticRelationship
     */
    'metadata': MechanisticMetadata;
}
/**
 * Median effect size.
 * @export
 * @enum {string}
 */

export enum MedianEffectSize {
    Small = 'small',
    Medium = 'medium',
    Large = 'large'
}

/**
 * A Message object.
 * @export
 * @interface MessageIn
 */
export interface MessageIn {
    /**
     * 
     * @type {string}
     * @memberof MessageIn
     */
    'message': string;
    /**
     * 
     * @type {MessageType}
     * @memberof MessageIn
     */
    'message_type'?: MessageType;
    /**
     * The message attributes
     * @type {any}
     * @memberof MessageIn
     */
    'attributes'?: any;
    /**
     * Integration link.
     * @type {string}
     * @memberof MessageIn
     */
    'integration': string;
}
/**
 * A Message object.
 * @export
 * @interface MessageOut
 */
export interface MessageOut {
    /**
     * 
     * @type {string}
     * @memberof MessageOut
     */
    'message': string;
    /**
     * 
     * @type {MessageType}
     * @memberof MessageOut
     */
    'message_type'?: MessageType;
    /**
     * The message attributes
     * @type {any}
     * @memberof MessageOut
     */
    'attributes'?: any;
    /**
     * Integration link.
     * @type {string}
     * @memberof MessageOut
     */
    'integration': string;
    /**
     * 
     * @type {number}
     * @memberof MessageOut
     */
    'id'?: number;
    /**
     * Creation date
     * @type {string}
     * @memberof MessageOut
     */
    'created'?: string;
}
/**
 * Message type.
 * @export
 * @enum {string}
 */

export enum MessageType {
    Error = 'ERROR',
    DatasetCreated = 'DATASET_CREATED'
}

/**
 * Metrics name enum.
 * @export
 * @enum {string}
 */

export enum Metrics {
    SemanticSearchCreate = 'semantic_search.create',
    SemanticSearchClusterRead = 'semantic_search_cluster.read',
    FindingsLogDoiLookup = 'findings_log.doi_lookup'
}

/**
 * Credentials for a Mode integration without the token and secret.
 * @export
 * @interface ModeCredentials
 */
export interface ModeCredentials {
    /**
     * Integration dashboard
     * @type {string}
     * @memberof ModeCredentials
     */
    'dashboard': string;
}
/**
 * Input credentials for a Mode integration.
 * @export
 * @interface ModeCredentialsIn
 */
export interface ModeCredentialsIn {
    /**
     * Integration dashboard
     * @type {string}
     * @memberof ModeCredentialsIn
     */
    'dashboard': string;
    /**
     * Integration api token.
     * @type {string}
     * @memberof ModeCredentialsIn
     */
    'api_token': string;
    /**
     * Integration api secret.
     * @type {string}
     * @memberof ModeCredentialsIn
     */
    'api_secret': string;
}
/**
 * Node group model.  # noqa: E501
 * @export
 * @interface NodeGroup
 */
export interface NodeGroup {
    /**
     * 
     * @type {Array<NodeGroupItem>}
     * @memberof NodeGroup
     */
    'items': Array<NodeGroupItem>;
    /**
     * 
     * @type {number}
     * @memberof NodeGroup
     */
    'total': number;
}
/**
 * Supported Node Object model.  # noqa: E501
 * @export
 * @interface NodeGroupItem
 */
export interface NodeGroupItem {
    /**
     * 
     * @type {Array<ExtendedLinkObject>}
     * @memberof NodeGroupItem
     */
    'links': Array<ExtendedLinkObject>;
    /**
     * 
     * @type {ExtendedNodeObject}
     * @memberof NodeGroupItem
     */
    'node': ExtendedNodeObject;
}
/**
 * Ordering direction enum.
 * @export
 * @enum {string}
 */

export enum Ordering {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * Path.  # noqa: E501
 * @export
 * @interface Path
 */
export interface Path {
    /**
     * 
     * @type {Array<string>}
     * @memberof Path
     */
    'edge_ids': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Path
     */
    'evidence_count': number;
}
/**
 * Map paths out.  # noqa: E501
 * @export
 * @interface PathsOut
 */
export interface PathsOut {
    /**
     * 
     * @type {number}
     * @memberof PathsOut
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PathsOut
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PathsOut
     */
    'total': number;
    /**
     * 
     * @type {Array<SohServiceClientModelsTopicNodeTopicNode>}
     * @memberof PathsOut
     */
    'nodes': Array<SohServiceClientModelsTopicNodeTopicNode>;
    /**
     * 
     * @type {Array<TopicEdge>}
     * @memberof PathsOut
     */
    'links': Array<TopicEdge>;
    /**
     * 
     * @type {Array<Path>}
     * @memberof PathsOut
     */
    'paths': Array<Path>;
}
/**
 * Typed paths payload.
 * @export
 * @interface PathsPayloadTyped
 */
export interface PathsPayloadTyped {
    /**
     * Number of hops.
     * @type {number}
     * @memberof PathsPayloadTyped
     */
    'n_hop': number;
    /**
     * Dictionary of topic filters with key corresponding to zero-indexed node in path.
     * @type {{ [key: string]: TopicFilterParams; }}
     * @memberof PathsPayloadTyped
     */
    'topic_filters'?: { [key: string]: TopicFilterParams; };
    /**
     * Dictionary of relationship filters with key corresponding to zero-indexed edge in path.
     * @type {{ [key: string]: RelationshipFilterParams; }}
     * @memberof PathsPayloadTyped
     */
    'relationship_filters'?: { [key: string]: RelationshipFilterParams; };
    /**
     * Sort field as sort_by:order. If not provided, paths are sorted by findings count.
     * @type {string}
     * @memberof PathsPayloadTyped
     */
    'sort'?: string;
    /**
     * Limit number of paths.
     * @type {number}
     * @memberof PathsPayloadTyped
     */
    'limit'?: number;
    /**
     * Offset number of paths.
     * @type {number}
     * @memberof PathsPayloadTyped
     */
    'offset'?: number;
}
/**
 * Polling status enum.
 * @export
 * @enum {string}
 */

export enum PollingStatus {
    NotExists = 'not_exists',
    Submitted = 'submitted',
    Running = 'running',
    Success = 'success',
    Failed = 'failed',
    FailedNoCitations = 'failed_no_citations',
    FailedValidation = 'failed_validation'
}

/**
 * 
 * @export
 * @interface QueryParserApiModelsPydanticGrounding
 */
export interface QueryParserApiModelsPydanticGrounding {
    /**
     * 
     * @type {string}
     * @memberof QueryParserApiModelsPydanticGrounding
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof QueryParserApiModelsPydanticGrounding
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof QueryParserApiModelsPydanticGrounding
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof QueryParserApiModelsPydanticGrounding
     */
    'score': number;
}
/**
 * Statistical finding.
 * @export
 * @interface RawFinding
 */
export interface RawFinding {
    /**
     * 
     * @type {string}
     * @memberof RawFinding
     */
    'association_id': string;
    /**
     * 
     * @type {string}
     * @memberof RawFinding
     */
    'variable_1': string;
    /**
     * 
     * @type {string}
     * @memberof RawFinding
     */
    'variable_2': string;
    /**
     * 
     * @type {boolean}
     * @memberof RawFinding
     */
    'bidirectional': boolean;
    /**
     * 
     * @type {FeatureContributionMethod}
     * @memberof RawFinding
     */
    'feature_contribution_method': FeatureContributionMethod;
    /**
     * 
     * @type {boolean}
     * @memberof RawFinding
     */
    'is_ratio': boolean;
    /**
     * 
     * @type {number}
     * @memberof RawFinding
     */
    'value': number;
    /**
     * 
     * @type {ConfidenceIntervalOut}
     * @memberof RawFinding
     */
    'ci'?: ConfidenceIntervalOut;
    /**
     * 
     * @type {number}
     * @memberof RawFinding
     */
    'p_value'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RawFinding
     */
    'flags'?: Array<string>;
}
/**
 * Credentials for a Redshift integration without password.
 * @export
 * @interface RedshiftCredentials
 */
export interface RedshiftCredentials {
    /**
     * Integration database name.
     * @type {string}
     * @memberof RedshiftCredentials
     */
    'db_name': string;
    /**
     * Integration user name.
     * @type {string}
     * @memberof RedshiftCredentials
     */
    'db_user': string;
    /**
     * Integration host (Required for Redshift).
     * @type {string}
     * @memberof RedshiftCredentials
     */
    'db_host': string;
    /**
     * Integration port (Required for Redshift).
     * @type {number}
     * @memberof RedshiftCredentials
     */
    'db_port': number;
}
/**
 * Input credentials for a Redshift integration.
 * @export
 * @interface RedshiftCredentialsIn
 */
export interface RedshiftCredentialsIn {
    /**
     * Integration database name.
     * @type {string}
     * @memberof RedshiftCredentialsIn
     */
    'db_name': string;
    /**
     * Integration user name.
     * @type {string}
     * @memberof RedshiftCredentialsIn
     */
    'db_user': string;
    /**
     * Integration host (Required for Redshift).
     * @type {string}
     * @memberof RedshiftCredentialsIn
     */
    'db_host': string;
    /**
     * Integration port (Required for Redshift).
     * @type {number}
     * @memberof RedshiftCredentialsIn
     */
    'db_port': number;
    /**
     * Integration password.
     * @type {string}
     * @memberof RedshiftCredentialsIn
     */
    'db_password': string;
}
/**
 * Filter parameters.  # noqa: E501
 * @export
 * @interface RelationshipFilterParams
 */
export interface RelationshipFilterParams {
    /**
     * 
     * @type {MedianEffectSize}
     * @memberof RelationshipFilterParams
     */
    'median_es_min'?: MedianEffectSize;
    /**
     * Highly cited.
     * @type {boolean}
     * @memberof RelationshipFilterParams
     */
    'highly_cited'?: boolean;
    /**
     * Well established.
     * @type {boolean}
     * @memberof RelationshipFilterParams
     */
    'well_established'?: boolean;
    /**
     * Significant well established.
     * @type {boolean}
     * @memberof RelationshipFilterParams
     */
    'significant_well_estabished'?: boolean;
    /**
     * Supported by experimental trials.
     * @type {boolean}
     * @memberof RelationshipFilterParams
     */
    'supported_by_experimental'?: boolean;
    /**
     * Recency limit years.
     * @type {number}
     * @memberof RelationshipFilterParams
     */
    'recency_limit_years'?: number;
    /**
     * Sample size minimum.
     * @type {number}
     * @memberof RelationshipFilterParams
     */
    'sample_size_min'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RelationshipFilterParams
     */
    'mechanism_types'?: Array<string>;
}
/**
 * Relationship types.
 * @export
 * @enum {string}
 */

export enum RelationshipTypes {
    Statistical = 'statistical',
    Mechanistic = 'mechanistic'
}

/**
 * API resource action enum.
 * @export
 * @enum {string}
 */

export enum ResourceAction {
    Create = 'create',
    View = 'view',
    Edit = 'edit',
    Delete = 'delete'
}

/**
 * A System Resource Flag Output Object.
 * @export
 * @interface ResourceFlag
 */
export interface ResourceFlag {
    /**
     * Given reasons for the flag.
     * @type {Array<string>}
     * @memberof ResourceFlag
     */
    'reasons': Array<string>;
    /**
     * Additional metadata for the flag.
     * @type {object}
     * @memberof ResourceFlag
     */
    'meta'?: object;
    /**
     * Time when resource was created.
     * @type {string}
     * @memberof ResourceFlag
     */
    'added_on': string;
    /**
     * User who created this resource.
     * @type {string}
     * @memberof ResourceFlag
     */
    'added_by': string;
}
/**
 * A System Resource Flag Input Object.
 * @export
 * @interface ResourceFlagIn
 */
export interface ResourceFlagIn {
    /**
     * Given reasons for the flag.
     * @type {Array<string>}
     * @memberof ResourceFlagIn
     */
    'reasons': Array<string>;
    /**
     * Additional metadata for the flag.
     * @type {object}
     * @memberof ResourceFlagIn
     */
    'meta'?: object;
}
/**
 * Table retrieval status.
 * @export
 * @enum {string}
 */

export enum RetrievalStatus {
    Pending = 'pending',
    Success = 'success',
    Failure = 'failure'
}

/**
 * Role.
 * @export
 * @enum {string}
 */

export enum Role {
    Determinant = 'Determinant',
    Intervention = 'Intervention',
    Outcome = 'Outcome',
    Agent = 'Agent'
}

/**
 * Schema for scored cluster.
 * @export
 * @interface ScoredCluster
 */
export interface ScoredCluster {
    /**
     * 
     * @type {number}
     * @memberof ScoredCluster
     */
    'sort_id': number;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'display_summary': string;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'prompt_summary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoredCluster
     */
    'cluster_labels': Array<string>;
    /**
     * 
     * @type {Array<Array<AppSchemaGroundingsGrounding>>}
     * @memberof ScoredCluster
     */
    'label_groundings'?: Array<Array<AppSchemaGroundingsGrounding>>;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'stat_descriptor'?: string;
    /**
     * Cluster-level metadata
     * @type {ClusteredEvidenceMetadata}
     * @memberof ScoredCluster
     */
    'cluster_metadata'?: ClusteredEvidenceMetadata;
    /**
     * 
     * @type {EvidenceCategory}
     * @memberof ScoredCluster
     */
    'evidence_category'?: EvidenceCategory;
    /**
     * 
     * @type {number}
     * @memberof ScoredCluster
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof ScoredCluster
     */
    'original_score'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoredCluster
     */
    'sort_bucket'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScoredCluster
     */
    'search_term_grounding_namespaces'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'reference_agent_position'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'other_agent_category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoredCluster
     */
    'modification_type'?: string;
}
/**
 * Search type.
 * @export
 * @enum {string}
 */

export enum SearchType {
    Semantic = 'semantic',
    Keyword = 'keyword'
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum SemanticSearchType {
    RiskFactorOf = 'risk_factor_of',
    Outcome = 'outcome',
    Relationship = 'relationship',
    Relationship2d = 'relationship_2d',
    SingleVariable2d = 'single_variable_2d'
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum SignificanceLevel {
    NinetyFive = 'ninety_five',
    NinetyNine = 'ninety_nine',
    NinetyNinePointNine = 'ninety_nine_point_nine',
    Invalid = 'invalid'
}

/**
 * Credentials for a Snowflake integration without password.
 * @export
 * @interface SnowflakeCredentials
 */
export interface SnowflakeCredentials {
    /**
     * Integration database name.
     * @type {string}
     * @memberof SnowflakeCredentials
     */
    'db_name': string;
    /**
     * Integration user name.
     * @type {string}
     * @memberof SnowflakeCredentials
     */
    'db_user': string;
    /**
     * Integration account name.
     * @type {string}
     * @memberof SnowflakeCredentials
     */
    'db_account': string;
    /**
     * Integration warehouse name.
     * @type {string}
     * @memberof SnowflakeCredentials
     */
    'db_warehouse': string;
}
/**
 * Input credentials for a Snowflake integration.
 * @export
 * @interface SnowflakeCredentialsIn
 */
export interface SnowflakeCredentialsIn {
    /**
     * Integration database name.
     * @type {string}
     * @memberof SnowflakeCredentialsIn
     */
    'db_name': string;
    /**
     * Integration user name.
     * @type {string}
     * @memberof SnowflakeCredentialsIn
     */
    'db_user': string;
    /**
     * Integration account name.
     * @type {string}
     * @memberof SnowflakeCredentialsIn
     */
    'db_account': string;
    /**
     * Integration warehouse name.
     * @type {string}
     * @memberof SnowflakeCredentialsIn
     */
    'db_warehouse': string;
    /**
     * Integration password.
     * @type {string}
     * @memberof SnowflakeCredentialsIn
     */
    'db_password': string;
}
/**
 * Interface for soh metadata.
 * @export
 * @interface Soh
 */
export interface Soh {
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'finding_sentence'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'study_population'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'statistic_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Soh
     */
    'statistic_value'?: number;
    /**
     * 
     * @type {object}
     * @memberof Soh
     */
    'significance_value'?: object;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'study_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'study_doi'?: string;
    /**
     * 
     * @type {number}
     * @memberof Soh
     */
    'study_cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'study_published_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'study_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'variable_1_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Soh
     */
    'variable_2_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Soh
     */
    'p_value'?: number;
}
/**
 * Interface for soh metadata on evidences.
 * @export
 * @interface SohEvidence
 */
export interface SohEvidence {
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'id': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof SohEvidence
     */
    'study_authors': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'study_published_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'study_doi': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'agent_1_name': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'agent_2_name': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'agent_1_id': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'agent_2_id': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'mechanism_type': string;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'source_statement'?: string;
    /**
     * 
     * @type {number}
     * @memberof SohEvidence
     */
    'study_cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof SohEvidence
     */
    'study_title'?: string;
}
/**
 * Interface for /soh response type.
 * @export
 * @interface SohEvidenceOut
 */
export interface SohEvidenceOut {
    /**
     * 
     * @type {Array<SohEvidence>}
     * @memberof SohEvidenceOut
     */
    'data': Array<SohEvidence>;
    /**
     * 
     * @type {string}
     * @memberof SohEvidenceOut
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof SohEvidenceOut
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohEvidenceOut
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohEvidenceOut
     */
    'total'?: number;
}
/**
 * Interface for input to /soh.
 * @export
 * @interface SohIn
 */
export interface SohIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof SohIn
     */
    'concept_1_group'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SohIn
     */
    'concept_2_group'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SohIn
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof SohIn
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohIn
     */
    'offset'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SohIn
     */
    'calculate_count'?: boolean;
}
/**
 * Interface for /soh response type.
 * @export
 * @interface SohOut
 */
export interface SohOut {
    /**
     * 
     * @type {Array<Soh>}
     * @memberof SohOut
     */
    'data': Array<Soh>;
    /**
     * 
     * @type {string}
     * @memberof SohOut
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof SohOut
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohOut
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohOut
     */
    'total'?: number;
}
/**
 * Statistical or Mechanistic Finding/Relationship.  # noqa: E501
 * @export
 * @interface SohServiceClientModelsFindingFinding
 */
export interface SohServiceClientModelsFindingFinding {
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'study_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'study_doi'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'association_id': string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'added_on': string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'variable_1_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'variable_2_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'mechanism_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'statistic_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'statistic_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'ci_upper'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'ci_lower'?: number;
    /**
     * 
     * @type {number}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'p_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'population'?: string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'sample_size'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof SohServiceClientModelsFindingFinding
     */
    'authors'?: Array<object>;
}
/**
 * Topic node.  # noqa: E501
 * @export
 * @interface SohServiceClientModelsTopicNodeTopicNode
 */
export interface SohServiceClientModelsTopicNodeTopicNode {
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'topic_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'umls_cuis': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'wikidata_id'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'roles': Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'mechanistic_category'?: string;
    /**
     * 
     * @type {Array<RelationshipTypes>}
     * @memberof SohServiceClientModelsTopicNodeTopicNode
     */
    'relationship_types'?: Array<RelationshipTypes>;
}
/**
 * Statistic relationship model.
 * @export
 * @interface StatisticRelationship
 */
export interface StatisticRelationship {
    /**
     * 
     * @type {string}
     * @memberof StatisticRelationship
     */
    'id': string;
    /**
     * 
     * @type {StatisticalMetadata}
     * @memberof StatisticRelationship
     */
    'metadata': StatisticalMetadata;
}
/**
 * Metadata for statistical finding.
 * @export
 * @interface StatisticalMetadata
 */
export interface StatisticalMetadata {
    /**
     * 
     * @type {Array<GroundedVariable>}
     * @memberof StatisticalMetadata
     */
    'variables': Array<GroundedVariable>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatisticalMetadata
     */
    'populations'?: Array<string>;
    /**
     * 
     * @type {StudyMetadataRDB}
     * @memberof StatisticalMetadata
     */
    'study_metadata'?: StudyMetadataRDB;
    /**
     * 
     * @type {string}
     * @memberof StatisticalMetadata
     */
    'statistic_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatisticalMetadata
     */
    'statistic_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalMetadata
     */
    'p_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatisticalMetadata
     */
    'ci_percent'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatisticalMetadata
     */
    'ci_lower'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalMetadata
     */
    'ci_upper'?: number;
}
/**
 * Stripe account status enum.
 * @export
 * @enum {string}
 */

export enum StripeAccountStatus {
    Trial = 'trial',
    Subscribed = 'subscribed',
    Expired = 'expired',
    GroupSubscribed = 'group_subscribed',
    Unsubscribed = 'unsubscribed'
}

/**
 * Stripe object.
 * @export
 * @interface StripeOut
 */
export interface StripeOut {
    /**
     * Subscription start date.
     * @type {string}
     * @memberof StripeOut
     */
    'start_date'?: string;
    /**
     * Subscription end date.
     * @type {string}
     * @memberof StripeOut
     */
    'end_date'?: string;
    /**
     * Subscription status.
     * @type {StripeAccountStatus}
     * @memberof StripeOut
     */
    'status'?: StripeAccountStatus;
    /**
     * Monthly or yearly.
     * @type {string}
     * @memberof StripeOut
     */
    'interval'?: string;
    /**
     * Autonew subscription
     * @type {boolean}
     * @memberof StripeOut
     */
    'cancel_at_period_end'?: boolean;
    /**
     * Subscription id.
     * @type {string}
     * @memberof StripeOut
     */
    'subscription_id'?: string;
    /**
     * Is group admin.
     * @type {boolean}
     * @memberof StripeOut
     */
    'is_group_admin'?: boolean;
    /**
     * Is group member.
     * @type {boolean}
     * @memberof StripeOut
     */
    'is_group_member'?: boolean;
    /**
     * Coupon code.
     * @type {string}
     * @memberof StripeOut
     */
    'coupon_id'?: string;
}
/**
 * Stripe session object.
 * @export
 * @interface StripeSessionOut
 */
export interface StripeSessionOut {
    /**
     * Session url link.
     * @type {string}
     * @memberof StripeSessionOut
     */
    'session_url'?: string;
}
/**
 * Study.  # noqa: E501
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'doi': string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'system_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'title': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Study
     */
    'authors': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'journal': string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'publish_date': string;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'abstract'?: string;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    'cited_by': number;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    'retraction_reason'?: string;
}
/**
 * Interface for an author on a study.
 * @export
 * @interface StudyAuthor
 */
export interface StudyAuthor {
    /**
     * 
     * @type {string}
     * @memberof StudyAuthor
     */
    'oa_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyAuthor
     */
    'name': string;
}
/**
 * Interface for a single study and its finding sentences, populations, sample size, and id.
 * @export
 * @interface StudyFindings
 */
export interface StudyFindings {
    /**
     * 
     * @type {Array<AppSchemaFindingsFinding>}
     * @memberof StudyFindings
     */
    'findings': Array<AppSchemaFindingsFinding>;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'doi': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyFindings
     */
    'populations'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StudyFindings
     */
    'sample_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'system_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyFindings
     */
    'pmid'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AuthorRDBOut>}
     * @memberof StudyFindings
     */
    'authors'?: Array<AuthorRDBOut>;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'study_summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'journal'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyFindings
     */
    'cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyFindings
     */
    'publish_date'?: string;
}
/**
 * Interface for /findings input.
 * @export
 * @interface StudyFindingsIn
 */
export interface StudyFindingsIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyFindingsIn
     */
    'association_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyFindingsIn
     */
    'dois'?: Array<string>;
}
/**
 * Interface for /findings response type.
 * @export
 * @interface StudyFindingsOut
 */
export interface StudyFindingsOut {
    /**
     * 
     * @type {Array<StudyFindings>}
     * @memberof StudyFindingsOut
     */
    'studies': Array<StudyFindings>;
}
/**
 * Interface for Study Metadata retrieved from DynamoD and OpenAlex.
 * @export
 * @interface StudyMetadata
 */
export interface StudyMetadata {
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'pmid'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'doi'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {Array<StudyAuthor>}
     * @memberof StudyMetadata
     */
    'authors'?: Array<StudyAuthor>;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'journal'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'journal_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyMetadata
     */
    'cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'publish_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadata
     */
    'summary'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StudyMetadata
     */
    'retracted'?: boolean;
}
/**
 * Interface for input to /study-metadata.
 * @export
 * @interface StudyMetadataIn
 */
export interface StudyMetadataIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyMetadataIn
     */
    'pmids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyMetadataIn
     */
    'filters'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataIn
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyMetadataIn
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof StudyMetadataIn
     */
    'offset'?: number;
}
/**
 * Interface for /study-metadata response type.
 * @export
 * @interface StudyMetadataOut
 */
export interface StudyMetadataOut {
    /**
     * 
     * @type {Array<StudyMetadata>}
     * @memberof StudyMetadataOut
     */
    'study_metadata': Array<StudyMetadata>;
}
/**
 * Interface for Study Metadata retrieved from SystemRDB.
 * @export
 * @interface StudyMetadataRDB
 */
export interface StudyMetadataRDB {
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'pmid'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'doi'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'name'?: string;
    /**
     * 
     * @type {Array<StudyAuthor>}
     * @memberof StudyMetadataRDB
     */
    'authors'?: Array<StudyAuthor>;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'journal'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyMetadataRDB
     */
    'cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'publish_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StudyMetadataRDB
     */
    'retracted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'study_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'abstract'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'study_summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyMetadataRDB
     */
    'study_population'?: string;
}
/**
 * Interface for /study-metadata RDB response type.
 * @export
 * @interface StudyMetadataRDBOut
 */
export interface StudyMetadataRDBOut {
    /**
     * 
     * @type {Array<StudyMetadataRDB>}
     * @memberof StudyMetadataRDBOut
     */
    'study_metadata': Array<StudyMetadataRDB>;
    /**
     * 
     * @type {number}
     * @memberof StudyMetadataRDBOut
     */
    'count': number;
}
/**
 * Study output.
 * @export
 * @interface StudyRDBOut
 */
export interface StudyRDBOut {
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'system_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'doi'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyRDBOut
     */
    'pmid'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'description'?: string;
    /**
     * 
     * @type {Array<AuthorRDBOut>}
     * @memberof StudyRDBOut
     */
    'authors'?: Array<AuthorRDBOut>;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'study_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'abstract'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'study_summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'study_population'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'journal'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyRDBOut
     */
    'cited_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyRDBOut
     */
    'publish_date'?: string;
}
/**
 * Subscription seats.
 * @export
 * @interface SubscriptionSeats
 */
export interface SubscriptionSeats {
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriptionSeats
     */
    'used_seats': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionSeats
     */
    'available_seats': number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionSeats
     */
    'total_seats': number;
}
/**
 * Schema for a System Pubmed Search.  # noqa: E501
 * @export
 * @interface SuggestedQueriesIn
 */
export interface SuggestedQueriesIn {
    /**
     * User query
     * @type {string}
     * @memberof SuggestedQueriesIn
     */
    'query': string;
    /**
     * Number of pubmed results.
     * @type {number}
     * @memberof SuggestedQueriesIn
     */
    'num_pubmed_results': number;
    /**
     * 
     * @type {SuggestedQueryType}
     * @memberof SuggestedQueriesIn
     */
    'suggestion_type'?: SuggestedQueryType;
}
/**
 * Schema for query suggestions.  # noqa: E501
 * @export
 * @interface SuggestedQueriesOut
 */
export interface SuggestedQueriesOut {
    /**
     * 
     * @type {Array<SuggestedQuery>}
     * @memberof SuggestedQueriesOut
     */
    'queries': Array<SuggestedQuery>;
}
/**
 * Suggested query.  # noqa: E501
 * @export
 * @interface SuggestedQuery
 */
export interface SuggestedQuery {
    /**
     * User query
     * @type {string}
     * @memberof SuggestedQuery
     */
    'query': string;
    /**
     * Number of pubmed results.
     * @type {number}
     * @memberof SuggestedQuery
     */
    'num_pubmed_results': number;
    /**
     * 
     * @type {SuggestedQueryType}
     * @memberof SuggestedQuery
     */
    'suggestion_type': SuggestedQueryType;
}
/**
 * Enum for query suggestion types.
 * @export
 * @enum {string}
 */

export enum SuggestedQueryType {
    Expanded = 'expanded',
    Autocorrect = 'autocorrect'
}

/**
 * Synthesis output schema.  # noqa: E501
 * @export
 * @interface Synthesis
 */
export interface Synthesis {
    /**
     * 
     * @type {string}
     * @memberof Synthesis
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof Synthesis
     */
    'cache_key': string;
}
/**
 * Information related to a thumbs down feedback.
 * @export
 * @interface SynthesisFeedback
 */
export interface SynthesisFeedback {
    /**
     * 
     * @type {Array<string>}
     * @memberof SynthesisFeedback
     */
    'choice'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SynthesisFeedback
     */
    'text': string;
}
/**
 * Input of feedback on synthesis from client.
 * @export
 * @interface SynthesisFeedbackIn
 */
export interface SynthesisFeedbackIn {
    /**
     * 
     * @type {string}
     * @memberof SynthesisFeedbackIn
     */
    'question': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SynthesisFeedbackIn
     */
    'prompt_summaries': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SynthesisFeedbackIn
     */
    'is_positive': boolean;
    /**
     * 
     * @type {SynthesisFeedback}
     * @memberof SynthesisFeedbackIn
     */
    'feedback_value'?: SynthesisFeedback;
    /**
     * 
     * @type {string}
     * @memberof SynthesisFeedbackIn
     */
    'cache_key'?: string;
}
/**
 * Synthesis fetching output schema.  # noqa: E501
 * @export
 * @interface SynthesisOut
 */
export interface SynthesisOut {
    /**
     * 
     * @type {PollingStatus}
     * @memberof SynthesisOut
     */
    'status': PollingStatus;
    /**
     * 
     * @type {Synthesis}
     * @memberof SynthesisOut
     */
    'synthesis': Synthesis;
}
/**
 * Synthesis response model.
 * @export
 * @interface SynthesisResponse
 */
export interface SynthesisResponse {
    /**
     * 
     * @type {ClusterOut}
     * @memberof SynthesisResponse
     */
    'main': ClusterOut;
    /**
     * 
     * @type {ClusterOut}
     * @memberof SynthesisResponse
     */
    'recent'?: ClusterOut;
    /**
     * 
     * @type {ClusterOut}
     * @memberof SynthesisResponse
     */
    'highly_cited'?: ClusterOut;
}
/**
 * Topic node.  # noqa: E501
 * @export
 * @interface SystemGraphApiClientModelsTopicNodeTopicNode
 */
export interface SystemGraphApiClientModelsTopicNodeTopicNode {
    /**
     * 
     * @type {string}
     * @memberof SystemGraphApiClientModelsTopicNodeTopicNode
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SystemGraphApiClientModelsTopicNodeTopicNode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SystemGraphApiClientModelsTopicNodeTopicNode
     */
    'wikidata_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemGraphApiClientModelsTopicNodeTopicNode
     */
    'semantic_types'?: Array<string>;
}
/**
 * System search underlying data.
 * @export
 * @interface SystemSearchData
 */
export interface SystemSearchData {
    /**
     * 
     * @type {Array<ClusteredRelationship>}
     * @memberof SystemSearchData
     */
    'relationships': Array<ClusteredRelationship>;
}
/**
 * Payload for system search data endpoints.
 * @export
 * @interface SystemSearchDataIn
 */
export interface SystemSearchDataIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemSearchDataIn
     */
    'pmids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SystemSearchDataIn
     */
    'population'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSearchDataIn
     */
    'variable_1_search'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSearchDataIn
     */
    'variable_2_search'?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchDataIn
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchDataIn
     */
    'offset': number;
}
/**
 * System Search Fields.
 * @export
 * @interface SystemSearchIn
 */
export interface SystemSearchIn {
    /**
     * Search Field type
     * @type {SemanticSearchType}
     * @memberof SystemSearchIn
     */
    'question_type'?: SemanticSearchType;
    /**
     * Question to search for.
     * @type {string}
     * @memberof SystemSearchIn
     */
    'question'?: string;
    /**
     * First term part of the question.
     * @type {GroundedEntity}
     * @memberof SystemSearchIn
     */
    'term1': GroundedEntity;
    /**
     * Optional second term part of the question.
     * @type {GroundedEntity}
     * @memberof SystemSearchIn
     */
    'term2'?: GroundedEntity;
    /**
     * Optional Field to filter studies which have populations matching Field.
     * @type {string}
     * @memberof SystemSearchIn
     */
    'population'?: string;
    /**
     * To use cache or not. Default True.
     * @type {boolean}
     * @memberof SystemSearchIn
     */
    'use_cache'?: boolean;
    /**
     * Clustering thresholds as json stringified list of pairs of floats.
     * @type {Array<Array<number>>}
     * @memberof SystemSearchIn
     */
    'clustering_thresholds'?: Array<Array<number>>;
    /**
     * Clustering method to use.
     * @type {ClusteringMethods}
     * @memberof SystemSearchIn
     */
    'clustering_method'?: ClusteringMethods;
    /**
     * Temperature of summary
     * @type {number}
     * @memberof SystemSearchIn
     */
    'temperature'?: number;
    /**
     * Use GPT4 model.
     * @type {boolean}
     * @memberof SystemSearchIn
     */
    'use_gpt4'?: boolean;
    /**
     * Filter studies that were added after this date (in yyyy/mm/dd format).
     * @type {string}
     * @memberof SystemSearchIn
     */
    'added_after'?: string;
    /**
     * Kickoff a recent synthesis.
     * @type {boolean}
     * @memberof SystemSearchIn
     */
    'kickoff_recent_synthesis'?: boolean;
    /**
     * Kickoff a highly cited synthesis.
     * @type {boolean}
     * @memberof SystemSearchIn
     */
    'kickoff_highly_cited_synthesis'?: boolean;
}
/**
 * System search underlying data.
 * @export
 * @interface SystemSearchMechanisticDataOut
 */
export interface SystemSearchMechanisticDataOut {
    /**
     * 
     * @type {Array<MechanisticRelationship>}
     * @memberof SystemSearchMechanisticDataOut
     */
    'relationships': Array<MechanisticRelationship>;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchMechanisticDataOut
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchMechanisticDataOut
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchMechanisticDataOut
     */
    'total': number;
}
/**
 * System search underlying data.
 * @export
 * @interface SystemSearchStatisticalDataOut
 */
export interface SystemSearchStatisticalDataOut {
    /**
     * 
     * @type {Array<StatisticRelationship>}
     * @memberof SystemSearchStatisticalDataOut
     */
    'relationships': Array<StatisticRelationship>;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchStatisticalDataOut
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchStatisticalDataOut
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof SystemSearchStatisticalDataOut
     */
    'total': number;
}
/**
 * A table object.
 * @export
 * @interface Table
 */
export interface Table {
    /**
     * 
     * @type {number}
     * @memberof Table
     */
    'id'?: number;
    /**
     * Table name.
     * @type {string}
     * @memberof Table
     */
    'name'?: string;
    /**
     * Active status.
     * @type {boolean}
     * @memberof Table
     */
    'active'?: boolean;
    /**
     * Schema name.
     * @type {string}
     * @memberof Table
     */
    'schema_name'?: string;
    /**
     * System ID of dataset this table corresponds to.
     * @type {string}
     * @memberof Table
     */
    'dataset_id'?: string;
    /**
     * Retrieval status.
     * @type {RetrievalStatus}
     * @memberof Table
     */
    'status'?: RetrievalStatus;
    /**
     * Time when table was last retrieved.
     * @type {string}
     * @memberof Table
     */
    'last_retrieval'?: string;
    /**
     * Time when interactions were last computed.
     * @type {string}
     * @memberof Table
     */
    'last_interactions_on'?: string;
    /**
     * Integration link.
     * @type {string}
     * @memberof Table
     */
    'integration': string;
}
/**
 * Time series data point.  # noqa: E501
 * @export
 * @interface TimeSeriesDataPoint
 */
export interface TimeSeriesDataPoint {
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesDataPoint
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesDataPoint
     */
    'value': number;
}
/**
 * Concept relationships model.  # noqa: E501
 * @export
 * @interface TopicCategories
 */
export interface TopicCategories {
    /**
     * 
     * @type {ExtendedNodeObject}
     * @memberof TopicCategories
     */
    'topic': ExtendedNodeObject;
    /**
     * 
     * @type {NodeGroupItem}
     * @memberof TopicCategories
     */
    'relationship'?: NodeGroupItem;
    /**
     * 
     * @type {NodeGroup}
     * @memberof TopicCategories
     */
    'upstream'?: NodeGroup;
    /**
     * 
     * @type {NodeGroup}
     * @memberof TopicCategories
     */
    'downstream'?: NodeGroup;
    /**
     * 
     * @type {NodeGroup}
     * @memberof TopicCategories
     */
    'confounders'?: NodeGroup;
    /**
     * 
     * @type {NodeGroup}
     * @memberof TopicCategories
     */
    'mediators'?: NodeGroup;
}
/**
 * Topic relationship.  # noqa: E501
 * @export
 * @interface TopicEdge
 */
export interface TopicEdge {
    /**
     * 
     * @type {string}
     * @memberof TopicEdge
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TopicEdge
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof TopicEdge
     */
    'target': string;
    /**
     * 
     * @type {number}
     * @memberof TopicEdge
     */
    'num_findings'?: number;
    /**
     * 
     * @type {number}
     * @memberof TopicEdge
     */
    'median_effect_size'?: number;
    /**
     * 
     * @type {object}
     * @memberof TopicEdge
     */
    'meta'?: object;
}
/**
 * Topic filter params.  # noqa: E501
 * @export
 * @interface TopicFilterParams
 */
export interface TopicFilterParams {
    /**
     * 
     * @type {Role}
     * @memberof TopicFilterParams
     */
    'role'?: Role;
    /**
     * 
     * @type {Array<string>}
     * @memberof TopicFilterParams
     */
    'include_category'?: Array<string>;
}
/**
 * Topic output.  # noqa: E501
 * @export
 * @interface TopicOut
 */
export interface TopicOut {
    /**
     * 
     * @type {string}
     * @memberof TopicOut
     */
    'system_id': string;
    /**
     * 
     * @type {string}
     * @memberof TopicOut
     */
    'wikidata_label': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TopicOut
     */
    'semantic_type_tree_numbers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TopicOut
     */
    'wikidata_id': string;
}
/**
 * Topic output.
 * @export
 * @interface TopicRDBOut
 */
export interface TopicRDBOut {
    /**
     * 
     * @type {string}
     * @memberof TopicRDBOut
     */
    'system_id': string;
    /**
     * 
     * @type {string}
     * @memberof TopicRDBOut
     */
    'wikidata_id': string;
    /**
     * 
     * @type {string}
     * @memberof TopicRDBOut
     */
    'wikidata_label': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TopicRDBOut
     */
    'semantic_type_tree_numbers'?: Array<string>;
}
/**
 * Interface for variables associated with a topic.
 * @export
 * @interface TopicVariablesOut
 */
export interface TopicVariablesOut {
    /**
     * 
     * @type {TopicRDBOut}
     * @memberof TopicVariablesOut
     */
    'topic': TopicRDBOut;
    /**
     * 
     * @type {Array<VariableInfo>}
     * @memberof TopicVariablesOut
     */
    'variables': Array<VariableInfo>;
    /**
     * 
     * @type {number}
     * @memberof TopicVariablesOut
     */
    'total': number;
}
/**
 * User profile data input.
 * @export
 * @interface UpdateProfileIn
 */
export interface UpdateProfileIn {
    /**
     * User name that is visible to others on System.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'display_name'?: string;
    /**
     * The user\'s unique [ORCID](https://orcid.org/).
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'orcid'?: string;
    /**
     * User\'s avatar.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'avatar'?: string;
    /**
     * User\'s first name.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'first_name'?: string;
    /**
     * User\'s last name.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'last_name'?: string;
    /**
     * User\'s organizations.
     * @type {Array<string>}
     * @memberof UpdateProfileIn
     */
    'organizations'?: Array<string>;
    /**
     * User\'s field of work.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'field_of_work'?: string;
    /**
     * User email address.
     * @type {string}
     * @memberof UpdateProfileIn
     */
    'email'?: string;
    /**
     * User roles.
     * @type {Array<string>}
     * @memberof UpdateProfileIn
     */
    'roles'?: Array<string>;
}
/**
 * User metric usage result.
 * @export
 * @interface UserMetricUsageOut
 */
export interface UserMetricUsageOut {
    /**
     * Usage Metric
     * @type {Metrics}
     * @memberof UserMetricUsageOut
     */
    'metric': Metrics;
    /**
     * Metric usage count
     * @type {number}
     * @memberof UserMetricUsageOut
     */
    'count': number;
    /**
     * Metric usage from date
     * @type {string}
     * @memberof UserMetricUsageOut
     */
    'date_from': string;
}
/**
 * Private user profile out.
 * @export
 * @interface UserPrivateProfileOut
 */
export interface UserPrivateProfileOut {
    /**
     * The user\'s System ID.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'id': string;
    /**
     * Time when the user\'s profile was created.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'created_at': string;
    /**
     * The Author ID corresponding to this user.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'author_id'?: string;
    /**
     * User name that is visible to others on System.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'display_name': string;
    /**
     * The user\'s unique [ORCID](https://orcid.org/).
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'orcid'?: string;
    /**
     * User\'s avatar.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'avatar'?: string;
    /**
     * User\'s first name.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'first_name'?: string;
    /**
     * User\'s last name.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'last_name'?: string;
    /**
     * User\'s organizations.
     * @type {Array<string>}
     * @memberof UserPrivateProfileOut
     */
    'organizations'?: Array<string>;
    /**
     * User\'s field of work.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'field_of_work'?: string;
    /**
     * User email address.
     * @type {string}
     * @memberof UserPrivateProfileOut
     */
    'email': string;
    /**
     * User roles.
     * @type {Array<string>}
     * @memberof UserPrivateProfileOut
     */
    'roles'?: Array<string>;
    /**
     * Stripe object
     * @type {StripeOut}
     * @memberof UserPrivateProfileOut
     */
    'stripe'?: StripeOut;
}
/**
 * User profile data input.
 * @export
 * @interface UserProfileIn
 */
export interface UserProfileIn {
    /**
     * User name that is visible to others on System.
     * @type {string}
     * @memberof UserProfileIn
     */
    'display_name': string;
    /**
     * The user\'s unique [ORCID](https://orcid.org/).
     * @type {string}
     * @memberof UserProfileIn
     */
    'orcid'?: string;
    /**
     * User\'s avatar.
     * @type {string}
     * @memberof UserProfileIn
     */
    'avatar'?: string;
    /**
     * User\'s first name.
     * @type {string}
     * @memberof UserProfileIn
     */
    'first_name'?: string;
    /**
     * User\'s last name.
     * @type {string}
     * @memberof UserProfileIn
     */
    'last_name'?: string;
    /**
     * User\'s organizations.
     * @type {Array<string>}
     * @memberof UserProfileIn
     */
    'organizations'?: Array<string>;
    /**
     * User\'s field of work.
     * @type {string}
     * @memberof UserProfileIn
     */
    'field_of_work'?: string;
    /**
     * User email address.
     * @type {string}
     * @memberof UserProfileIn
     */
    'email': string;
    /**
     * User roles.
     * @type {Array<string>}
     * @memberof UserProfileIn
     */
    'roles'?: Array<string>;
}
/**
 * Public user profile out.
 * @export
 * @interface UserPublicProfileOut
 */
export interface UserPublicProfileOut {
    /**
     * The user\'s System ID.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'id': string;
    /**
     * Time when the user\'s profile was created.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'created_at': string;
    /**
     * The Author ID corresponding to this user.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'author_id'?: string;
    /**
     * User name that is visible to others on System.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'display_name': string;
    /**
     * The user\'s unique [ORCID](https://orcid.org/).
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'orcid'?: string;
    /**
     * User\'s avatar.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'avatar'?: string;
    /**
     * User\'s first name.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'first_name'?: string;
    /**
     * User\'s last name.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'last_name'?: string;
    /**
     * User\'s organizations.
     * @type {Array<string>}
     * @memberof UserPublicProfileOut
     */
    'organizations'?: Array<string>;
    /**
     * User\'s field of work.
     * @type {string}
     * @memberof UserPublicProfileOut
     */
    'field_of_work'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * Variable grounding model.
 * @export
 * @interface VariableGrounding
 */
export interface VariableGrounding {
    /**
     * 
     * @type {string}
     * @memberof VariableGrounding
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableGrounding
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof VariableGrounding
     */
    'name': string;
}
/**
 * Interface for a variable\'s info.
 * @export
 * @interface VariableInfo
 */
export interface VariableInfo {
    /**
     * 
     * @type {string}
     * @memberof VariableInfo
     */
    'variable_id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableInfo
     */
    'variable_name': string;
    /**
     * 
     * @type {number}
     * @memberof VariableInfo
     */
    'num_studies': number;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDataAccessV1AccessDataPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/access/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMapsAccessV1AccessMapsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/access/maps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessApiAxiosParamCreator(configuration)
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestDataAccessV1AccessDataPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestDataAccessV1AccessDataPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestMapsAccessV1AccessMapsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestMapsAccessV1AccessMapsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessApiFp(configuration)
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDataAccessV1AccessDataPost(options?: any): AxiosPromise<any> {
            return localVarFp.requestDataAccessV1AccessDataPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMapsAccessV1AccessMapsPost(options?: any): AxiosPromise<any> {
            return localVarFp.requestMapsAccessV1AccessMapsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * Register user\'s interest in access to Data Beta.
     * @summary Request Data Access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public requestDataAccessV1AccessDataPost(options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).requestDataAccessV1AccessDataPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user\'s interest in access to Maps Beta.
     * @summary Request Maps Access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public requestMapsAccessV1AccessMapsPost(options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).requestMapsAccessV1AccessMapsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssociationsApi - axios parameter creator
 * @export
 */
export const AssociationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost: async (associationId: string, resourceFlagIn: ResourceFlagIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'associationId' is not null or undefined
            assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost', 'associationId', associationId)
            // verify required parameter 'resourceFlagIn' is not null or undefined
            assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost', 'resourceFlagIn', resourceFlagIn)
            const localVarPath = `/v1/associations/{association_id}/flags`
                .replace(`{${"association_id"}}`, encodeURIComponent(String(associationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceFlagIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost_1: async (associationId: string, resourceFlagIn: ResourceFlagIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'associationId' is not null or undefined
            assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost_1', 'associationId', associationId)
            // verify required parameter 'resourceFlagIn' is not null or undefined
            assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost_1', 'resourceFlagIn', resourceFlagIn)
            const localVarPath = `/v1/associations/{association_id}/flags`
                .replace(`{${"association_id"}}`, encodeURIComponent(String(associationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceFlagIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFreeMetadataV1AssociationsFreeMetadataGet: async (ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/associations/free_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssociationsApi - functional programming interface
 * @export
 */
export const AssociationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssociationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flagAssociationV1AssociationsAssociationIdFlagsPost(associationId: string, resourceFlagIn: ResourceFlagIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId: string, resourceFlagIn: ResourceFlagIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFreeMetadataV1AssociationsFreeMetadataGet(ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFreeMetadataV1AssociationsFreeMetadataGet(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssociationsApi - factory interface
 * @export
 */
export const AssociationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssociationsApiFp(configuration)
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost(associationId: string, resourceFlagIn: ResourceFlagIn, options?: any): AxiosPromise<any> {
            return localVarFp.flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId 
         * @param {ResourceFlagIn} resourceFlagIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId: string, resourceFlagIn: ResourceFlagIn, options?: any): AxiosPromise<any> {
            return localVarFp.flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options).then((request) => request(axios, basePath));
        },
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFreeMetadataV1AssociationsFreeMetadataGet(ids?: Array<string>, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.listFreeMetadataV1AssociationsFreeMetadataGet(ids, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for flagAssociationV1AssociationsAssociationIdFlagsPost operation in AssociationsApi.
 * @export
 * @interface AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPostRequest
 */
export interface AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost
     */
    readonly associationId: string

    /**
     * 
     * @type {ResourceFlagIn}
     * @memberof AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost
     */
    readonly resourceFlagIn: ResourceFlagIn
}

/**
 * Request parameters for flagAssociationV1AssociationsAssociationIdFlagsPost_1 operation in AssociationsApi.
 * @export
 * @interface AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0Request
 */
export interface AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0Request {
    /**
     * 
     * @type {string}
     * @memberof AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0
     */
    readonly associationId: string

    /**
     * 
     * @type {ResourceFlagIn}
     * @memberof AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0
     */
    readonly resourceFlagIn: ResourceFlagIn
}

/**
 * Request parameters for listFreeMetadataV1AssociationsFreeMetadataGet operation in AssociationsApi.
 * @export
 * @interface AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGetRequest
 */
export interface AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGetRequest {
    /**
     * List of association IDs to fetch free metadata for.
     * @type {Array<string>}
     * @memberof AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGet
     */
    readonly ids?: Array<string>
}

/**
 * AssociationsApi - object-oriented interface
 * @export
 * @class AssociationsApi
 * @extends {BaseAPI}
 */
export class AssociationsApi extends BaseAPI {
    /**
     * Get strength of this association.
     * @summary Flag Association
     * @param {AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    public flagAssociationV1AssociationsAssociationIdFlagsPost(requestParameters: AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPostRequest, options?: AxiosRequestConfig) {
        return AssociationsApiFp(this.configuration).flagAssociationV1AssociationsAssociationIdFlagsPost(requestParameters.associationId, requestParameters.resourceFlagIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get strength of this association.
     * @summary Flag Association
     * @param {AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    public flagAssociationV1AssociationsAssociationIdFlagsPost_1(requestParameters: AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0Request, options?: AxiosRequestConfig) {
        return AssociationsApiFp(this.configuration).flagAssociationV1AssociationsAssociationIdFlagsPost_1(requestParameters.associationId, requestParameters.resourceFlagIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Associations.
     * @summary List Free Metadata
     * @param {AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    public listFreeMetadataV1AssociationsFreeMetadataGet(requestParameters: AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGetRequest = {}, options?: AxiosRequestConfig) {
        return AssociationsApiFp(this.configuration).listFreeMetadataV1AssociationsFreeMetadataGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConceptsApi - axios parameter creator
 * @export
 */
export const ConceptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId 
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet: async (conceptId: string, topPercentileLimit?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptId' is not null or undefined
            assertParamExists('getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet', 'conceptId', conceptId)
            const localVarPath = `/v1/concepts/{concept_id}/relationships`
                .replace(`{${"concept_id"}}`, encodeURIComponent(String(conceptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topPercentileLimit !== undefined) {
                localVarQueryParameter['top_percentile_limit'] = topPercentileLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptV1ConceptsConceptIdGet: async (conceptId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptId' is not null or undefined
            assertParamExists('getConceptV1ConceptsConceptIdGet', 'conceptId', conceptId)
            const localVarPath = `/v1/concepts/{concept_id}`
                .replace(`{${"concept_id"}}`, encodeURIComponent(String(conceptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId] 
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConceptsV1ConceptsGet: async (teamId?: string, minRelationshipStrength?: number, query?: string, includeHidden?: boolean, id?: Array<string>, page?: number, pageSize?: number, total?: boolean, idsOnly?: boolean, orderBy?: ConceptSortEnum, ordering?: Ordering, sortBy?: string, inConceptGraph?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (minRelationshipStrength !== undefined) {
                localVarQueryParameter['min_relationship_strength'] = minRelationshipStrength;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['include_hidden'] = includeHidden;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (idsOnly !== undefined) {
                localVarQueryParameter['ids_only'] = idsOnly;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (inConceptGraph !== undefined) {
                localVarQueryParameter['in_concept_graph'] = inConceptGraph;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchConceptsV1ConceptsSemanticGet: async (query: string, alpha?: number, autocut?: number, customCutoffScore?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('semanticSearchConceptsV1ConceptsSemanticGet', 'query', query)
            const localVarPath = `/v1/concepts/semantic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (alpha !== undefined) {
                localVarQueryParameter['alpha'] = alpha;
            }

            if (autocut !== undefined) {
                localVarQueryParameter['autocut'] = autocut;
            }

            if (customCutoffScore !== undefined) {
                localVarQueryParameter['custom_cutoff_score'] = customCutoffScore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConceptsApi - functional programming interface
 * @export
 */
export const ConceptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConceptsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId 
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId: string, topPercentileLimit?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptRelationshipsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConceptV1ConceptsConceptIdGet(conceptId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConceptV1ConceptsConceptIdGet(conceptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId] 
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConceptsV1ConceptsGet(teamId?: string, minRelationshipStrength?: number, query?: string, includeHidden?: boolean, id?: Array<string>, page?: number, pageSize?: number, total?: boolean, idsOnly?: boolean, orderBy?: ConceptSortEnum, ordering?: Ordering, sortBy?: string, inConceptGraph?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptPaginationOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async semanticSearchConceptsV1ConceptsSemanticGet(query: string, alpha?: number, autocut?: number, customCutoffScore?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConceptsApi - factory interface
 * @export
 */
export const ConceptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConceptsApiFp(configuration)
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId 
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId: string, topPercentileLimit?: boolean, options?: any): AxiosPromise<ConceptRelationshipsOut> {
            return localVarFp.getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptV1ConceptsConceptIdGet(conceptId: string, options?: any): AxiosPromise<ConceptOut> {
            return localVarFp.getConceptV1ConceptsConceptIdGet(conceptId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId] 
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConceptsV1ConceptsGet(teamId?: string, minRelationshipStrength?: number, query?: string, includeHidden?: boolean, id?: Array<string>, page?: number, pageSize?: number, total?: boolean, idsOnly?: boolean, orderBy?: ConceptSortEnum, ordering?: Ordering, sortBy?: string, inConceptGraph?: boolean, options?: any): AxiosPromise<ConceptPaginationOut> {
            return localVarFp.listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchConceptsV1ConceptsSemanticGet(query: string, alpha?: number, autocut?: number, customCutoffScore?: number, limit?: number, options?: any): AxiosPromise<Array<ConceptOut>> {
            return localVarFp.semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet operation in ConceptsApi.
 * @export
 * @interface ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGetRequest
 */
export interface ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGet
     */
    readonly conceptId: string

    /**
     * Flag for limiting to top percentile.
     * @type {boolean}
     * @memberof ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGet
     */
    readonly topPercentileLimit?: boolean
}

/**
 * Request parameters for getConceptV1ConceptsConceptIdGet operation in ConceptsApi.
 * @export
 * @interface ConceptsApiGetConceptV1ConceptsConceptIdGetRequest
 */
export interface ConceptsApiGetConceptV1ConceptsConceptIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConceptsApiGetConceptV1ConceptsConceptIdGet
     */
    readonly conceptId: string
}

/**
 * Request parameters for listConceptsV1ConceptsGet operation in ConceptsApi.
 * @export
 * @interface ConceptsApiListConceptsV1ConceptsGetRequest
 */
export interface ConceptsApiListConceptsV1ConceptsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly teamId?: string

    /**
     * Min strength
     * @type {number}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly minRelationshipStrength?: number

    /**
     * Search query.
     * @type {string}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly query?: string

    /**
     * Include hidden objects in results.
     * @type {boolean}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly includeHidden?: boolean

    /**
     * Filter results by id.
     * @type {Array<string>}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly pageSize?: number

    /**
     * Include total count in response. Only use if you need it as a separate database call is required.
     * @type {boolean}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly total?: boolean

    /**
     * Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
     * @type {boolean}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly idsOnly?: boolean

    /**
     * Order by this field.
     * @type {ConceptSortEnum}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly orderBy?: ConceptSortEnum

    /**
     * Order ascending or descending.
     * @type {Ordering}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly ordering?: Ordering

    /**
     * Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
     * @type {string}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly sortBy?: string

    /**
     * Is Concept in the Concept Graph?
     * @type {boolean}
     * @memberof ConceptsApiListConceptsV1ConceptsGet
     */
    readonly inConceptGraph?: boolean
}

/**
 * Request parameters for semanticSearchConceptsV1ConceptsSemanticGet operation in ConceptsApi.
 * @export
 * @interface ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGetRequest
 */
export interface ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGetRequest {
    /**
     * Query for the search.
     * @type {string}
     * @memberof ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGet
     */
    readonly query: string

    /**
     * Alpha for the search.
     * @type {number}
     * @memberof ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGet
     */
    readonly alpha?: number

    /**
     * Autocut for the search.
     * @type {number}
     * @memberof ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGet
     */
    readonly autocut?: number

    /**
     * Custom cutoff score.
     * @type {number}
     * @memberof ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGet
     */
    readonly customCutoffScore?: number

    /**
     * Limit for the search.
     * @type {number}
     * @memberof ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGet
     */
    readonly limit?: number
}

/**
 * ConceptsApi - object-oriented interface
 * @export
 * @class ConceptsApi
 * @extends {BaseAPI}
 */
export class ConceptsApi extends BaseAPI {
    /**
     * Fetch concept relationships.
     * @summary Get Concept Relationships
     * @param {ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(requestParameters: ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGetRequest, options?: AxiosRequestConfig) {
        return ConceptsApiFp(this.configuration).getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(requestParameters.conceptId, requestParameters.topPercentileLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Concept.
     * @summary Get Concept
     * @param {ConceptsApiGetConceptV1ConceptsConceptIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public getConceptV1ConceptsConceptIdGet(requestParameters: ConceptsApiGetConceptV1ConceptsConceptIdGetRequest, options?: AxiosRequestConfig) {
        return ConceptsApiFp(this.configuration).getConceptV1ConceptsConceptIdGet(requestParameters.conceptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Concepts.
     * @summary List Concepts
     * @param {ConceptsApiListConceptsV1ConceptsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public listConceptsV1ConceptsGet(requestParameters: ConceptsApiListConceptsV1ConceptsGetRequest = {}, options?: AxiosRequestConfig) {
        return ConceptsApiFp(this.configuration).listConceptsV1ConceptsGet(requestParameters.teamId, requestParameters.minRelationshipStrength, requestParameters.query, requestParameters.includeHidden, requestParameters.id, requestParameters.page, requestParameters.pageSize, requestParameters.total, requestParameters.idsOnly, requestParameters.orderBy, requestParameters.ordering, requestParameters.sortBy, requestParameters.inConceptGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Concepts.
     * @summary Semantic Search Concepts
     * @param {ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    public semanticSearchConceptsV1ConceptsSemanticGet(requestParameters: ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGetRequest, options?: AxiosRequestConfig) {
        return ConceptsApiFp(this.configuration).semanticSearchConceptsV1ConceptsSemanticGet(requestParameters.query, requestParameters.alpha, requestParameters.autocut, requestParameters.customCutoffScore, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnterpriseApi - axios parameter creator
 * @export
 */
export const EnterpriseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationV1EnterpriseIntegrationsPost: async (integrationIn: IntegrationIn, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationIn' is not null or undefined
            assertParamExists('createIntegrationV1EnterpriseIntegrationsPost', 'integrationIn', integrationIn)
            const localVarPath = `/v1/enterprise/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageV1EnterpriseMessagesPost: async (messageIn: MessageIn, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageIn' is not null or undefined
            assertParamExists('createMessageV1EnterpriseMessagesPost', 'messageIn', messageIn)
            const localVarPath = `/v1/enterprise/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterpriseV1EnterpriseGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/enterprise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationV1EnterpriseIntegrationsIntegrationIdGet: async (integrationId: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getIntegrationV1EnterpriseIntegrationsIntegrationIdGet', 'integrationId', integrationId)
            const localVarPath = `/v1/enterprise/integrations/{integration_id}`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsV1EnterpriseIntegrationsGet: async (teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/enterprise/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageV1EnterpriseMessagesMessageIdGet: async (messageId: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageV1EnterpriseMessagesMessageIdGet', 'messageId', messageId)
            const localVarPath = `/v1/enterprise/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterpriseV1EnterprisePatch: async (enterpriseIn: EnterpriseIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseIn' is not null or undefined
            assertParamExists('updateEnterpriseV1EnterprisePatch', 'enterpriseIn', enterpriseIn)
            const localVarPath = `/v1/enterprise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enterpriseIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId 
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch: async (integrationId: string, integrationIn: IntegrationIn, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch', 'integrationId', integrationId)
            // verify required parameter 'integrationIn' is not null or undefined
            assertParamExists('updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch', 'integrationIn', integrationIn)
            const localVarPath = `/v1/enterprise/integrations/{integration_id}`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId 
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageV1EnterpriseMessagesMessageIdPatch: async (messageId: string, messageIn: MessageIn, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateMessageV1EnterpriseMessagesMessageIdPatch', 'messageId', messageId)
            // verify required parameter 'messageIn' is not null or undefined
            assertParamExists('updateMessageV1EnterpriseMessagesMessageIdPatch', 'messageIn', messageIn)
            const localVarPath = `/v1/enterprise/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnterpriseApi - functional programming interface
 * @export
 */
export const EnterpriseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnterpriseApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegrationV1EnterpriseIntegrationsPost(integrationIn: IntegrationIn, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageV1EnterpriseMessagesPost(messageIn: MessageIn, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageV1EnterpriseMessagesPost(messageIn, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnterpriseV1EnterpriseGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enterprise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnterpriseV1EnterpriseGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId: string, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationsV1EnterpriseIntegrationsGet(teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Integration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationsV1EnterpriseIntegrationsGet(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageV1EnterpriseMessagesMessageIdGet(messageId: string, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnterpriseV1EnterprisePatch(enterpriseIn: EnterpriseIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enterprise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnterpriseV1EnterprisePatch(enterpriseIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId 
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId: string, integrationIn: IntegrationIn, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId 
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessageV1EnterpriseMessagesMessageIdPatch(messageId: string, messageIn: MessageIn, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnterpriseApi - factory interface
 * @export
 */
export const EnterpriseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnterpriseApiFp(configuration)
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationV1EnterpriseIntegrationsPost(integrationIn: IntegrationIn, teamId?: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageV1EnterpriseMessagesPost(messageIn: MessageIn, teamId?: string, options?: any): AxiosPromise<MessageOut> {
            return localVarFp.createMessageV1EnterpriseMessagesPost(messageIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterpriseV1EnterpriseGet(options?: any): AxiosPromise<Enterprise> {
            return localVarFp.getEnterpriseV1EnterpriseGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId: string, teamId?: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsV1EnterpriseIntegrationsGet(teamId?: string, options?: any): AxiosPromise<Array<Integration>> {
            return localVarFp.getIntegrationsV1EnterpriseIntegrationsGet(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageV1EnterpriseMessagesMessageIdGet(messageId: string, teamId?: string, options?: any): AxiosPromise<MessageOut> {
            return localVarFp.getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterpriseV1EnterprisePatch(enterpriseIn: EnterpriseIn, options?: any): AxiosPromise<Enterprise> {
            return localVarFp.updateEnterpriseV1EnterprisePatch(enterpriseIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId 
         * @param {IntegrationIn} integrationIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId: string, integrationIn: IntegrationIn, teamId?: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId 
         * @param {MessageIn} messageIn 
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageV1EnterpriseMessagesMessageIdPatch(messageId: string, messageIn: MessageIn, teamId?: string, options?: any): AxiosPromise<MessageOut> {
            return localVarFp.updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createIntegrationV1EnterpriseIntegrationsPost operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPostRequest
 */
export interface EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPostRequest {
    /**
     * 
     * @type {IntegrationIn}
     * @memberof EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPost
     */
    readonly integrationIn: IntegrationIn

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPost
     */
    readonly teamId?: string
}

/**
 * Request parameters for createMessageV1EnterpriseMessagesPost operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiCreateMessageV1EnterpriseMessagesPostRequest
 */
export interface EnterpriseApiCreateMessageV1EnterpriseMessagesPostRequest {
    /**
     * 
     * @type {MessageIn}
     * @memberof EnterpriseApiCreateMessageV1EnterpriseMessagesPost
     */
    readonly messageIn: MessageIn

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiCreateMessageV1EnterpriseMessagesPost
     */
    readonly teamId?: string
}

/**
 * Request parameters for getIntegrationV1EnterpriseIntegrationsIntegrationIdGet operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGetRequest
 */
export interface EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGet
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGet
     */
    readonly teamId?: string
}

/**
 * Request parameters for getIntegrationsV1EnterpriseIntegrationsGet operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGetRequest
 */
export interface EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGet
     */
    readonly teamId?: string
}

/**
 * Request parameters for getMessageV1EnterpriseMessagesMessageIdGet operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGetRequest
 */
export interface EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGet
     */
    readonly messageId: string

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGet
     */
    readonly teamId?: string
}

/**
 * Request parameters for updateEnterpriseV1EnterprisePatch operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiUpdateEnterpriseV1EnterprisePatchRequest
 */
export interface EnterpriseApiUpdateEnterpriseV1EnterprisePatchRequest {
    /**
     * 
     * @type {EnterpriseIn}
     * @memberof EnterpriseApiUpdateEnterpriseV1EnterprisePatch
     */
    readonly enterpriseIn: EnterpriseIn
}

/**
 * Request parameters for updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatchRequest
 */
export interface EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch
     */
    readonly integrationId: string

    /**
     * 
     * @type {IntegrationIn}
     * @memberof EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch
     */
    readonly integrationIn: IntegrationIn

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch
     */
    readonly teamId?: string
}

/**
 * Request parameters for updateMessageV1EnterpriseMessagesMessageIdPatch operation in EnterpriseApi.
 * @export
 * @interface EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatchRequest
 */
export interface EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatch
     */
    readonly messageId: string

    /**
     * 
     * @type {MessageIn}
     * @memberof EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatch
     */
    readonly messageIn: MessageIn

    /**
     * 
     * @type {string}
     * @memberof EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatch
     */
    readonly teamId?: string
}

/**
 * EnterpriseApi - object-oriented interface
 * @export
 * @class EnterpriseApi
 * @extends {BaseAPI}
 */
export class EnterpriseApi extends BaseAPI {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createIntegrationV1EnterpriseIntegrationsPost(requestParameters: EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPostRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createIntegrationV1EnterpriseIntegrationsPost(requestParameters.integrationIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new message.
     * @summary Create Message
     * @param {EnterpriseApiCreateMessageV1EnterpriseMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createMessageV1EnterpriseMessagesPost(requestParameters: EnterpriseApiCreateMessageV1EnterpriseMessagesPostRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createMessageV1EnterpriseMessagesPost(requestParameters.messageIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Enterprise.
     * @summary Get Enterprise
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getEnterpriseV1EnterpriseGet(options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getEnterpriseV1EnterpriseGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Integration.
     * @summary Get Integration
     * @param {EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(requestParameters: EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGetRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(requestParameters.integrationId, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get team integrations.
     * @summary Get Integrations
     * @param {EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getIntegrationsV1EnterpriseIntegrationsGet(requestParameters: EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGetRequest = {}, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getIntegrationsV1EnterpriseIntegrationsGet(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Message.
     * @summary Get Message
     * @param {EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getMessageV1EnterpriseMessagesMessageIdGet(requestParameters: EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGetRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getMessageV1EnterpriseMessagesMessageIdGet(requestParameters.messageId, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Enterprise.
     * @summary Update Enterprise
     * @param {EnterpriseApiUpdateEnterpriseV1EnterprisePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateEnterpriseV1EnterprisePatch(requestParameters: EnterpriseApiUpdateEnterpriseV1EnterprisePatchRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateEnterpriseV1EnterprisePatch(requestParameters.enterpriseIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Integration.
     * @summary Update Integration
     * @param {EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(requestParameters: EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatchRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(requestParameters.integrationId, requestParameters.integrationIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Message.
     * @summary Update Message
     * @param {EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateMessageV1EnterpriseMessagesMessageIdPatch(requestParameters: EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatchRequest, options?: AxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateMessageV1EnterpriseMessagesMessageIdPatch(requestParameters.messageId, requestParameters.messageIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save feedback on a finding.
         * @summary Post Finding Feedback
         * @param {string} findingId 
         * @param {FindingFeedbackIn} findingFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindingFeedbackV1FeedbackFindingIdPost: async (findingId: string, findingFeedbackIn: FindingFeedbackIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingId' is not null or undefined
            assertParamExists('postFindingFeedbackV1FeedbackFindingIdPost', 'findingId', findingId)
            // verify required parameter 'findingFeedbackIn' is not null or undefined
            assertParamExists('postFindingFeedbackV1FeedbackFindingIdPost', 'findingFeedbackIn', findingFeedbackIn)
            const localVarPath = `/v1/feedback/{finding_id}`
                .replace(`{${"finding_id"}}`, encodeURIComponent(String(findingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findingFeedbackIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSynthesisFeedbackV1FeedbackPost: async (synthesisFeedbackIn: SynthesisFeedbackIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'synthesisFeedbackIn' is not null or undefined
            assertParamExists('postSynthesisFeedbackV1FeedbackPost', 'synthesisFeedbackIn', synthesisFeedbackIn)
            const localVarPath = `/v1/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(synthesisFeedbackIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * Save feedback on a finding.
         * @summary Post Finding Feedback
         * @param {string} findingId 
         * @param {FindingFeedbackIn} findingFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFindingFeedbackV1FeedbackFindingIdPost(findingId: string, findingFeedbackIn: FindingFeedbackIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFindingFeedbackV1FeedbackFindingIdPost(findingId, findingFeedbackIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn: SynthesisFeedbackIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * Save feedback on a finding.
         * @summary Post Finding Feedback
         * @param {string} findingId 
         * @param {FindingFeedbackIn} findingFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindingFeedbackV1FeedbackFindingIdPost(findingId: string, findingFeedbackIn: FindingFeedbackIn, options?: any): AxiosPromise<any> {
            return localVarFp.postFindingFeedbackV1FeedbackFindingIdPost(findingId, findingFeedbackIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn: SynthesisFeedbackIn, options?: any): AxiosPromise<any> {
            return localVarFp.postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for postFindingFeedbackV1FeedbackFindingIdPost operation in FeedbackApi.
 * @export
 * @interface FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPostRequest
 */
export interface FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPost
     */
    readonly findingId: string

    /**
     * 
     * @type {FindingFeedbackIn}
     * @memberof FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPost
     */
    readonly findingFeedbackIn: FindingFeedbackIn
}

/**
 * Request parameters for postSynthesisFeedbackV1FeedbackPost operation in FeedbackApi.
 * @export
 * @interface FeedbackApiPostSynthesisFeedbackV1FeedbackPostRequest
 */
export interface FeedbackApiPostSynthesisFeedbackV1FeedbackPostRequest {
    /**
     * 
     * @type {SynthesisFeedbackIn}
     * @memberof FeedbackApiPostSynthesisFeedbackV1FeedbackPost
     */
    readonly synthesisFeedbackIn: SynthesisFeedbackIn
}

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * Save feedback on a finding.
     * @summary Post Finding Feedback
     * @param {FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public postFindingFeedbackV1FeedbackFindingIdPost(requestParameters: FeedbackApiPostFindingFeedbackV1FeedbackFindingIdPostRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).postFindingFeedbackV1FeedbackFindingIdPost(requestParameters.findingId, requestParameters.findingFeedbackIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post user feedback on AI-generated relationship synthesis to s3.
     * @summary Post Synthesis Feedback
     * @param {FeedbackApiPostSynthesisFeedbackV1FeedbackPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public postSynthesisFeedbackV1FeedbackPost(requestParameters: FeedbackApiPostSynthesisFeedbackV1FeedbackPostRequest, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).postSynthesisFeedbackV1FeedbackPost(requestParameters.synthesisFeedbackIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FindingsApi - axios parameter creator
 * @export
 */
export const FindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost: async (studyFindingsIn: StudyFindingsIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyFindingsIn' is not null or undefined
            assertParamExists('getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost', 'studyFindingsIn', studyFindingsIn)
            const localVarPath = `/v1/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyFindingsIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FindingsApi - functional programming interface
 * @export
 */
export const FindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn: StudyFindingsIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyFindingsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FindingsApi - factory interface
 * @export
 */
export const FindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FindingsApiFp(configuration)
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn: StudyFindingsIn, options?: any): AxiosPromise<StudyFindingsOut> {
            return localVarFp.getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost operation in FindingsApi.
 * @export
 * @interface FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPostRequest
 */
export interface FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPostRequest {
    /**
     * 
     * @type {StudyFindingsIn}
     * @memberof FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost
     */
    readonly studyFindingsIn: StudyFindingsIn
}

/**
 * FindingsApi - object-oriented interface
 * @export
 * @class FindingsApi
 * @extends {BaseAPI}
 */
export class FindingsApi extends BaseAPI {
    /**
     * Get study findings via association ids or dois.
     * @summary Get Study Findings From Association Ids Or Dois
     * @param {FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FindingsApi
     */
    public getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(requestParameters: FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPostRequest, options?: AxiosRequestConfig) {
        return FindingsApiFp(this.configuration).getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(requestParameters.studyFindingsIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetricsV1MetricsGraphGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/metrics/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphMetricsV1MetricsGraphGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphMetricsV1MetricsGraphGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetricsV1MetricsGraphGet(options?: any): AxiosPromise<GraphMetrics> {
            return localVarFp.getGraphMetricsV1MetricsGraphGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Get metrics on the graph.
     * @summary Get Graph Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getGraphMetricsV1MetricsGraphGet(options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getGraphMetricsV1MetricsGraphGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModeldbApi - axios parameter creator
 * @export
 */
export const ModeldbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet: async (algorithmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmId' is not null or undefined
            assertParamExists('getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet', 'algorithmId', algorithmId)
            const localVarPath = `/v1/modeldb/algorithms/{algorithm_id}`
                .replace(`{${"algorithm_id"}}`, encodeURIComponent(String(algorithmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithmsV1ModeldbAlgorithmsGet: async (algorithmClass?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/modeldb/algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (algorithmClass !== undefined) {
                localVarQueryParameter['algorithm_class'] = algorithmClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModeldbApi - functional programming interface
 * @export
 */
export const ModeldbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModeldbApiAxiosParamCreator(configuration)
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlgorithmOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlgorithmListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModeldbApi - factory interface
 * @export
 */
export const ModeldbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModeldbApiFp(configuration)
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId: string, options?: any): AxiosPromise<AlgorithmOut> {
            return localVarFp.getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass?: string, options?: any): AxiosPromise<AlgorithmListResult> {
            return localVarFp.listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet operation in ModeldbApi.
 * @export
 * @interface ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGetRequest
 */
export interface ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet
     */
    readonly algorithmId: string
}

/**
 * Request parameters for listAlgorithmsV1ModeldbAlgorithmsGet operation in ModeldbApi.
 * @export
 * @interface ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGetRequest
 */
export interface ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGet
     */
    readonly algorithmClass?: string
}

/**
 * ModeldbApi - object-oriented interface
 * @export
 * @class ModeldbApi
 * @extends {BaseAPI}
 */
export class ModeldbApi extends BaseAPI {
    /**
     * Get algorithms by id.
     * @summary Get Algorithm
     * @param {ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModeldbApi
     */
    public getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(requestParameters: ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGetRequest, options?: AxiosRequestConfig) {
        return ModeldbApiFp(this.configuration).getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(requestParameters.algorithmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available algorithms in ModelDB. Search with algorithm class if passed.
     * @summary List Algorithms
     * @param {ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModeldbApi
     */
    public listAlgorithmsV1ModeldbAlgorithmsGet(requestParameters: ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGetRequest = {}, options?: AxiosRequestConfig) {
        return ModeldbApiFp(this.configuration).listAlgorithmsV1ModeldbAlgorithmsGet(requestParameters.algorithmClass, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PassthroughApi - axios parameter creator
 * @export
 */
export const PassthroughApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossrefV1CrossrefRestOfPathGet: async (restOfPath: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restOfPath' is not null or undefined
            assertParamExists('getCrossrefV1CrossrefRestOfPathGet', 'restOfPath', restOfPath)
            const localVarPath = `/v1/crossref/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFtrEntitlementsV1GetftrEntitlementsPost: async (getFTREntitlementsIn: GetFTREntitlementsIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFTREntitlementsIn' is not null or undefined
            assertParamExists('getFtrEntitlementsV1GetftrEntitlementsPost', 'getFTREntitlementsIn', getFTREntitlementsIn)
            const localVarPath = `/v1/getftr/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFTREntitlementsIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrcidV1OrcidRestOfPathGet: async (restOfPath: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restOfPath' is not null or undefined
            assertParamExists('getOrcidV1OrcidRestOfPathGet', 'restOfPath', restOfPath)
            const localVarPath = `/v1/orcid/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphV1SemanticGraphRestOfPathGet: async (restOfPath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restOfPath' is not null or undefined
            assertParamExists('getSemanticGraphV1SemanticGraphRestOfPathGet', 'restOfPath', restOfPath)
            const localVarPath = `/v1/semantic_graph/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmlsConceptsV1UmlsRestOfPathGet: async (restOfPath: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restOfPath' is not null or undefined
            assertParamExists('getUmlsConceptsV1UmlsRestOfPathGet', 'restOfPath', restOfPath)
            const localVarPath = `/v1/umls/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableConceptsV1VariableConceptsRestOfPathGet: async (restOfPath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restOfPath' is not null or undefined
            assertParamExists('getVariableConceptsV1VariableConceptsRestOfPathGet', 'restOfPath', restOfPath)
            const localVarPath = `/v1/variable_concepts/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphqlV1GraphqlPost: async (graphQLQuery: GraphQLQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphQLQuery' is not null or undefined
            assertParamExists('postGraphqlV1GraphqlPost', 'graphQLQuery', graphQLQuery)
            const localVarPath = `/v1/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphQLQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassthroughApi - functional programming interface
 * @export
 */
export const PassthroughApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassthroughApiAxiosParamCreator(configuration)
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossrefV1CrossrefRestOfPathGet(restOfPath: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrossrefV1CrossrefRestOfPathGet(restOfPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn: GetFTREntitlementsIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFTREntitlementsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrcidV1OrcidRestOfPathGet(restOfPath: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrcidV1OrcidRestOfPathGet(restOfPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUmlsConceptsV1UmlsRestOfPathGet(restOfPath: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGraphqlV1GraphqlPost(graphQLQuery: GraphQLQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGraphqlV1GraphqlPost(graphQLQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PassthroughApi - factory interface
 * @export
 */
export const PassthroughApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassthroughApiFp(configuration)
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossrefV1CrossrefRestOfPathGet(restOfPath: any, options?: any): AxiosPromise<any> {
            return localVarFp.getCrossrefV1CrossrefRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn: GetFTREntitlementsIn, options?: any): AxiosPromise<GetFTREntitlementsOut> {
            return localVarFp.getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrcidV1OrcidRestOfPathGet(restOfPath: any, options?: any): AxiosPromise<any> {
            return localVarFp.getOrcidV1OrcidRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmlsConceptsV1UmlsRestOfPathGet(restOfPath: any, options?: any): AxiosPromise<any> {
            return localVarFp.getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphqlV1GraphqlPost(graphQLQuery: GraphQLQuery, options?: any): AxiosPromise<any> {
            return localVarFp.postGraphqlV1GraphqlPost(graphQLQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCrossrefV1CrossrefRestOfPathGet operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetCrossrefV1CrossrefRestOfPathGetRequest
 */
export interface PassthroughApiGetCrossrefV1CrossrefRestOfPathGetRequest {
    /**
     * 
     * @type {any}
     * @memberof PassthroughApiGetCrossrefV1CrossrefRestOfPathGet
     */
    readonly restOfPath: any
}

/**
 * Request parameters for getFtrEntitlementsV1GetftrEntitlementsPost operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPostRequest
 */
export interface PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPostRequest {
    /**
     * 
     * @type {GetFTREntitlementsIn}
     * @memberof PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPost
     */
    readonly getFTREntitlementsIn: GetFTREntitlementsIn
}

/**
 * Request parameters for getOrcidV1OrcidRestOfPathGet operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetOrcidV1OrcidRestOfPathGetRequest
 */
export interface PassthroughApiGetOrcidV1OrcidRestOfPathGetRequest {
    /**
     * 
     * @type {any}
     * @memberof PassthroughApiGetOrcidV1OrcidRestOfPathGet
     */
    readonly restOfPath: any
}

/**
 * Request parameters for getSemanticGraphV1SemanticGraphRestOfPathGet operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGetRequest
 */
export interface PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGet
     */
    readonly restOfPath: string
}

/**
 * Request parameters for getUmlsConceptsV1UmlsRestOfPathGet operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGetRequest
 */
export interface PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGetRequest {
    /**
     * 
     * @type {any}
     * @memberof PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGet
     */
    readonly restOfPath: any
}

/**
 * Request parameters for getVariableConceptsV1VariableConceptsRestOfPathGet operation in PassthroughApi.
 * @export
 * @interface PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGetRequest
 */
export interface PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGet
     */
    readonly restOfPath: string
}

/**
 * Request parameters for postGraphqlV1GraphqlPost operation in PassthroughApi.
 * @export
 * @interface PassthroughApiPostGraphqlV1GraphqlPostRequest
 */
export interface PassthroughApiPostGraphqlV1GraphqlPostRequest {
    /**
     * 
     * @type {GraphQLQuery}
     * @memberof PassthroughApiPostGraphqlV1GraphqlPost
     */
    readonly graphQLQuery: GraphQLQuery
}

/**
 * PassthroughApi - object-oriented interface
 * @export
 * @class PassthroughApi
 * @extends {BaseAPI}
 */
export class PassthroughApi extends BaseAPI {
    /**
     * Forward request to crossref.
     * @summary Get Crossref
     * @param {PassthroughApiGetCrossrefV1CrossrefRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getCrossrefV1CrossrefRestOfPathGet(requestParameters: PassthroughApiGetCrossrefV1CrossrefRestOfPathGetRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getCrossrefV1CrossrefRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post GetFTR entitlements endpoint.
     * @summary Get Ftr Entitlements
     * @param {PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getFtrEntitlementsV1GetftrEntitlementsPost(requestParameters: PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPostRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getFtrEntitlementsV1GetftrEntitlementsPost(requestParameters.getFTREntitlementsIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forward request to ORCID.
     * @summary Get Orcid
     * @param {PassthroughApiGetOrcidV1OrcidRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getOrcidV1OrcidRestOfPathGet(requestParameters: PassthroughApiGetOrcidV1OrcidRestOfPathGetRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getOrcidV1OrcidRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forward request to SearchGraph.
     * @summary Get Semantic Graph
     * @param {PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getSemanticGraphV1SemanticGraphRestOfPathGet(requestParameters: PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGetRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getSemanticGraphV1SemanticGraphRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forward request to UMLS.
     * @summary Get Umls Concepts
     * @param {PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getUmlsConceptsV1UmlsRestOfPathGet(requestParameters: PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGetRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getUmlsConceptsV1UmlsRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forward request to SearchGraph.
     * @summary Get Variable Concepts
     * @param {PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public getVariableConceptsV1VariableConceptsRestOfPathGet(requestParameters: PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGetRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).getVariableConceptsV1VariableConceptsRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forward GraphQL request to SystemDB.
     * @summary Post Graphql
     * @param {PassthroughApiPostGraphqlV1GraphqlPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    public postGraphqlV1GraphqlPost(requestParameters: PassthroughApiPostGraphqlV1GraphqlPostRequest, options?: AxiosRequestConfig) {
        return PassthroughApiFp(this.configuration).postGraphqlV1GraphqlPost(requestParameters.graphQLQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuerySuggestionsApi - axios parameter creator
 * @export
 */
export const QuerySuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsV1QuerySuggestionsPost: async (suggestedQueriesIn: SuggestedQueriesIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestedQueriesIn' is not null or undefined
            assertParamExists('getQuerySuggestionsV1QuerySuggestionsPost', 'suggestedQueriesIn', suggestedQueriesIn)
            const localVarPath = `/v1/query_suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestedQueriesIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuerySuggestionsApi - functional programming interface
 * @export
 */
export const QuerySuggestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuerySuggestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn: SuggestedQueriesIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuggestedQueriesOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuerySuggestionsApi - factory interface
 * @export
 */
export const QuerySuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuerySuggestionsApiFp(configuration)
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn: SuggestedQueriesIn, options?: any): AxiosPromise<SuggestedQueriesOut> {
            return localVarFp.getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getQuerySuggestionsV1QuerySuggestionsPost operation in QuerySuggestionsApi.
 * @export
 * @interface QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPostRequest
 */
export interface QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPostRequest {
    /**
     * 
     * @type {SuggestedQueriesIn}
     * @memberof QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPost
     */
    readonly suggestedQueriesIn: SuggestedQueriesIn
}

/**
 * QuerySuggestionsApi - object-oriented interface
 * @export
 * @class QuerySuggestionsApi
 * @extends {BaseAPI}
 */
export class QuerySuggestionsApi extends BaseAPI {
    /**
     * Get query suggestions.
     * @summary Get Query Suggestions.
     * @param {QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuerySuggestionsApi
     */
    public getQuerySuggestionsV1QuerySuggestionsPost(requestParameters: QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPostRequest, options?: AxiosRequestConfig) {
        return QuerySuggestionsApiFp(this.configuration).getQuerySuggestionsV1QuerySuggestionsPost(requestParameters.suggestedQueriesIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RdbApi - axios parameter creator
 * @export
 */
export const RdbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readEvidencesV1RdbEvidencesGet: async (ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rdb/evidences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudiesV1RdbStudiesGet: async (ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rdb/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RdbApi - functional programming interface
 * @export
 */
export const RdbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RdbApiAxiosParamCreator(configuration)
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readEvidencesV1RdbEvidencesGet(ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvidenceRDBOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readEvidencesV1RdbEvidencesGet(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudiesV1RdbStudiesGet(ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudyRDBOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudiesV1RdbStudiesGet(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RdbApi - factory interface
 * @export
 */
export const RdbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RdbApiFp(configuration)
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readEvidencesV1RdbEvidencesGet(ids?: Array<string>, options?: any): AxiosPromise<Array<EvidenceRDBOut>> {
            return localVarFp.readEvidencesV1RdbEvidencesGet(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudiesV1RdbStudiesGet(ids?: Array<string>, options?: any): AxiosPromise<Array<StudyRDBOut>> {
            return localVarFp.readStudiesV1RdbStudiesGet(ids, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for readEvidencesV1RdbEvidencesGet operation in RdbApi.
 * @export
 * @interface RdbApiReadEvidencesV1RdbEvidencesGetRequest
 */
export interface RdbApiReadEvidencesV1RdbEvidencesGetRequest {
    /**
     * Evidence ids
     * @type {Array<string>}
     * @memberof RdbApiReadEvidencesV1RdbEvidencesGet
     */
    readonly ids?: Array<string>
}

/**
 * Request parameters for readStudiesV1RdbStudiesGet operation in RdbApi.
 * @export
 * @interface RdbApiReadStudiesV1RdbStudiesGetRequest
 */
export interface RdbApiReadStudiesV1RdbStudiesGetRequest {
    /**
     * Study ids
     * @type {Array<string>}
     * @memberof RdbApiReadStudiesV1RdbStudiesGet
     */
    readonly ids?: Array<string>
}

/**
 * RdbApi - object-oriented interface
 * @export
 * @class RdbApi
 * @extends {BaseAPI}
 */
export class RdbApi extends BaseAPI {
    /**
     * Read evidences.
     * @summary Read Evidences
     * @param {RdbApiReadEvidencesV1RdbEvidencesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RdbApi
     */
    public readEvidencesV1RdbEvidencesGet(requestParameters: RdbApiReadEvidencesV1RdbEvidencesGetRequest = {}, options?: AxiosRequestConfig) {
        return RdbApiFp(this.configuration).readEvidencesV1RdbEvidencesGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read studies.
     * @summary Read Studies
     * @param {RdbApiReadStudiesV1RdbStudiesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RdbApi
     */
    public readStudiesV1RdbStudiesGet(requestParameters: RdbApiReadStudiesV1RdbStudiesGetRequest = {}, options?: AxiosRequestConfig) {
        return RdbApiFp(this.configuration).readStudiesV1RdbStudiesGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SemanticSearchApi - axios parameter creator
 * @export
 */
export const SemanticSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost: async (systemSearchIn: SystemSearchIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchIn' is not null or undefined
            assertParamExists('asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost', 'systemSearchIn', systemSearchIn)
            const localVarPath = `/v1/semantic-search/cluster_async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncSemanticSearchV1SemanticSearchClusterPost: async (systemSearchIn: SystemSearchIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchIn' is not null or undefined
            assertParamExists('asyncSemanticSearchV1SemanticSearchClusterPost', 'systemSearchIn', systemSearchIn)
            const localVarPath = `/v1/semantic-search/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet: async (runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet', 'runId', runId)
            const localVarPath = `/v1/semantic-search/cluster_async/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSynthesisV1SemanticSearchFetchGet: async (cacheKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cacheKey' is not null or undefined
            assertParamExists('fetchSynthesisV1SemanticSearchFetchGet', 'cacheKey', cacheKey)
            const localVarPath = `/v1/semantic-search/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (cacheKey !== undefined) {
                localVarQueryParameter['cache_key'] = cacheKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search relationship map.
         * @summary Get Relationship Map Endpoint
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost: async (systemSearchIn: SystemSearchIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchIn' is not null or undefined
            assertParamExists('getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost', 'systemSearchIn', systemSearchIn)
            const localVarPath = `/v1/semantic-search/relationship_map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom] 
         * @param {Metrics} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticSearchUsageV1SemanticSearchUsageGet: async (dateFrom?: string, metric?: Metrics, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/semantic-search/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substr(0,10) :
                    dateFrom;
            }

            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchFindingsDataV1SemanticSearchDataPost: async (systemSearchIn: SystemSearchIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchIn' is not null or undefined
            assertParamExists('getSystemSearchFindingsDataV1SemanticSearchDataPost', 'systemSearchIn', systemSearchIn)
            const localVarPath = `/v1/semantic-search/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistical findings.
         * @summary Get System Search Mechanistic Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost: async (systemSearchDataIn: SystemSearchDataIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchDataIn' is not null or undefined
            assertParamExists('getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost', 'systemSearchDataIn', systemSearchDataIn)
            const localVarPath = `/v1/semantic-search/data/mechanistic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchDataIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mechanistic findings.
         * @summary Get System Search Statistical Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost: async (systemSearchDataIn: SystemSearchDataIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSearchDataIn' is not null or undefined
            assertParamExists('getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost', 'systemSearchDataIn', systemSearchDataIn)
            const localVarPath = `/v1/semantic-search/data/statistical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSearchDataIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey 
         * @param {boolean} [forceRerun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateSynthesisV1SemanticSearchRegeneratePost: async (cacheKey: string, forceRerun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cacheKey' is not null or undefined
            assertParamExists('regenerateSynthesisV1SemanticSearchRegeneratePost', 'cacheKey', cacheKey)
            const localVarPath = `/v1/semantic-search/regenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (cacheKey !== undefined) {
                localVarQueryParameter['cache_key'] = cacheKey;
            }

            if (forceRerun !== undefined) {
                localVarQueryParameter['force_rerun'] = forceRerun;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SemanticSearchApi - functional programming interface
 * @export
 */
export const SemanticSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SemanticSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn: SystemSearchIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn: SystemSearchIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SynthesisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterOutStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchSynthesisV1SemanticSearchFetchGet(cacheKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SynthesisOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search relationship map.
         * @summary Get Relationship Map Endpoint
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(systemSearchIn: SystemSearchIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(systemSearchIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom] 
         * @param {Metrics} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom?: string, metric?: Metrics, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMetricUsageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn: SystemSearchIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSearchData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get statistical findings.
         * @summary Get System Search Mechanistic Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(systemSearchDataIn: SystemSearchDataIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSearchMechanisticDataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(systemSearchDataIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get mechanistic findings.
         * @summary Get System Search Statistical Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(systemSearchDataIn: SystemSearchDataIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSearchStatisticalDataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(systemSearchDataIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey 
         * @param {boolean} [forceRerun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey: string, forceRerun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SemanticSearchApi - factory interface
 * @export
 */
export const SemanticSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SemanticSearchApiFp(configuration)
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn: SystemSearchIn, options?: any): AxiosPromise<any> {
            return localVarFp.asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn: SystemSearchIn, options?: any): AxiosPromise<SynthesisResponse> {
            return localVarFp.asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId: string, options?: any): AxiosPromise<ClusterOutStatus> {
            return localVarFp.fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSynthesisV1SemanticSearchFetchGet(cacheKey: string, options?: any): AxiosPromise<SynthesisOut> {
            return localVarFp.fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search relationship map.
         * @summary Get Relationship Map Endpoint
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(systemSearchIn: SystemSearchIn, options?: any): AxiosPromise<any> {
            return localVarFp.getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom] 
         * @param {Metrics} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom?: string, metric?: Metrics, options?: any): AxiosPromise<UserMetricUsageOut> {
            return localVarFp.getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn: SystemSearchIn, options?: any): AxiosPromise<SystemSearchData> {
            return localVarFp.getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistical findings.
         * @summary Get System Search Mechanistic Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(systemSearchDataIn: SystemSearchDataIn, options?: any): AxiosPromise<SystemSearchMechanisticDataOut> {
            return localVarFp.getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(systemSearchDataIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get mechanistic findings.
         * @summary Get System Search Statistical Data
         * @param {SystemSearchDataIn} systemSearchDataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(systemSearchDataIn: SystemSearchDataIn, options?: any): AxiosPromise<SystemSearchStatisticalDataOut> {
            return localVarFp.getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(systemSearchDataIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey 
         * @param {boolean} [forceRerun] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey: string, forceRerun?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPostRequest
 */
export interface SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPostRequest {
    /**
     * 
     * @type {SystemSearchIn}
     * @memberof SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPost
     */
    readonly systemSearchIn: SystemSearchIn
}

/**
 * Request parameters for asyncSemanticSearchV1SemanticSearchClusterPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPostRequest
 */
export interface SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPostRequest {
    /**
     * 
     * @type {SystemSearchIn}
     * @memberof SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPost
     */
    readonly systemSearchIn: SystemSearchIn
}

/**
 * Request parameters for fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGetRequest
 */
export interface SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet
     */
    readonly runId: string
}

/**
 * Request parameters for fetchSynthesisV1SemanticSearchFetchGet operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGetRequest
 */
export interface SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGet
     */
    readonly cacheKey: string
}

/**
 * Request parameters for getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetRelationshipMapEndpointV1SemanticSearchRelationshipMapPostRequest
 */
export interface SemanticSearchApiGetRelationshipMapEndpointV1SemanticSearchRelationshipMapPostRequest {
    /**
     * 
     * @type {SystemSearchIn}
     * @memberof SemanticSearchApiGetRelationshipMapEndpointV1SemanticSearchRelationshipMapPost
     */
    readonly systemSearchIn: SystemSearchIn
}

/**
 * Request parameters for getSemanticSearchUsageV1SemanticSearchUsageGet operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGetRequest
 */
export interface SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGet
     */
    readonly dateFrom?: string

    /**
     * 
     * @type {Metrics}
     * @memberof SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGet
     */
    readonly metric?: Metrics
}

/**
 * Request parameters for getSystemSearchFindingsDataV1SemanticSearchDataPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPostRequest
 */
export interface SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPostRequest {
    /**
     * 
     * @type {SystemSearchIn}
     * @memberof SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPost
     */
    readonly systemSearchIn: SystemSearchIn
}

/**
 * Request parameters for getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPostRequest
 */
export interface SemanticSearchApiGetSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPostRequest {
    /**
     * 
     * @type {SystemSearchDataIn}
     * @memberof SemanticSearchApiGetSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost
     */
    readonly systemSearchDataIn: SystemSearchDataIn
}

/**
 * Request parameters for getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPostRequest
 */
export interface SemanticSearchApiGetSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPostRequest {
    /**
     * 
     * @type {SystemSearchDataIn}
     * @memberof SemanticSearchApiGetSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost
     */
    readonly systemSearchDataIn: SystemSearchDataIn
}

/**
 * Request parameters for regenerateSynthesisV1SemanticSearchRegeneratePost operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePostRequest
 */
export interface SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePostRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePost
     */
    readonly cacheKey: string

    /**
     * 
     * @type {boolean}
     * @memberof SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePost
     */
    readonly forceRerun?: boolean
}

/**
 * SemanticSearchApi - object-oriented interface
 * @export
 * @class SemanticSearchApi
 * @extends {BaseAPI}
 */
export class SemanticSearchApi extends BaseAPI {
    /**
     * Get semantic search.  Values from semantic search.
     * @summary Async Cluster Relationships
     * @param {SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(requestParameters: SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search.  Values from semantic search.
     * @summary Async Semantic Search
     * @param {SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public asyncSemanticSearchV1SemanticSearchClusterPost(requestParameters: SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).asyncSemanticSearchV1SemanticSearchClusterPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search.  Values from semantic search.
     * @summary Fetch Cluster Response
     * @param {SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(requestParameters: SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGetRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search.  Values from semantic search. Logs freemium usage on success
     * @summary Fetch Synthesis
     * @param {SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public fetchSynthesisV1SemanticSearchFetchGet(requestParameters: SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGetRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).fetchSynthesisV1SemanticSearchFetchGet(requestParameters.cacheKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search relationship map.
     * @summary Get Relationship Map Endpoint
     * @param {SemanticSearchApiGetRelationshipMapEndpointV1SemanticSearchRelationshipMapPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(requestParameters: SemanticSearchApiGetRelationshipMapEndpointV1SemanticSearchRelationshipMapPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getRelationshipMapEndpointV1SemanticSearchRelationshipMapPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
     * @summary Get Semantic Search Usage
     * @param {SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSemanticSearchUsageV1SemanticSearchUsageGet(requestParameters: SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGetRequest = {}, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSemanticSearchUsageV1SemanticSearchUsageGet(requestParameters.dateFrom, requestParameters.metric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search findings.  Values from semantic search.
     * @summary Get System Search Findings Data
     * @param {SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSystemSearchFindingsDataV1SemanticSearchDataPost(requestParameters: SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSystemSearchFindingsDataV1SemanticSearchDataPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistical findings.
     * @summary Get System Search Mechanistic Data
     * @param {SemanticSearchApiGetSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(requestParameters: SemanticSearchApiGetSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSystemSearchMechanisticDataV1SemanticSearchDataMechanisticPost(requestParameters.systemSearchDataIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get mechanistic findings.
     * @summary Get System Search Statistical Data
     * @param {SemanticSearchApiGetSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(requestParameters: SemanticSearchApiGetSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSystemSearchStatisticalDataV1SemanticSearchDataStatisticalPost(requestParameters.systemSearchDataIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get semantic search.  Values from semantic search.
     * @summary Regenerate Synthesis
     * @param {SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public regenerateSynthesisV1SemanticSearchRegeneratePost(requestParameters: SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePostRequest, options?: AxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).regenerateSynthesisV1SemanticSearchRegeneratePost(requestParameters.cacheKey, requestParameters.forceRerun, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SohApi - axios parameter creator
 * @export
 */
export const SohApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch graph.
         * @summary Fetch Graph Time Series Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/soh/metrics/time-series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch graph.
         * @summary Fetch Mech Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost: async (topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost', 'topicId', topicId)
            // verify required parameter 'traversalDirection' is not null or undefined
            assertParamExists('fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost', 'traversalDirection', traversalDirection)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/mech_relationships/{topic_id}/graph/{traversal_direction}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)))
                .replace(`{${"traversal_direction"}}`, encodeURIComponent(String(traversalDirection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch mediators.
         * @summary Fetch Mech Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost: async (topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost', 'topicId', topicId)
            // verify required parameter 'targetTopicId' is not null or undefined
            assertParamExists('fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost', 'targetTopicId', targetTopicId)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/mech_relationships/{topic_id}/paths/mediators`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (targetTopicId !== undefined) {
                localVarQueryParameter['target_topic_id'] = targetTopicId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch paths.
         * @summary Fetch Mech Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost: async (topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost', 'topicId', topicId)
            // verify required parameter 'traversalDirection' is not null or undefined
            assertParamExists('fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost', 'traversalDirection', traversalDirection)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/mech_relationships/{topic_id}/paths/{traversal_direction}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)))
                .replace(`{${"traversal_direction"}}`, encodeURIComponent(String(traversalDirection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch graph.
         * @summary Fetch Stat Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost: async (topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost', 'topicId', topicId)
            // verify required parameter 'traversalDirection' is not null or undefined
            assertParamExists('fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost', 'traversalDirection', traversalDirection)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/stat_relationships/{topic_id}/graph/{traversal_direction}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)))
                .replace(`{${"traversal_direction"}}`, encodeURIComponent(String(traversalDirection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch mediators.
         * @summary Fetch Stat Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost: async (topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost', 'topicId', topicId)
            // verify required parameter 'targetTopicId' is not null or undefined
            assertParamExists('fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost', 'targetTopicId', targetTopicId)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/stat_relationships/{topic_id}/paths/mediators`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (targetTopicId !== undefined) {
                localVarQueryParameter['target_topic_id'] = targetTopicId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch paths.
         * @summary Fetch Stat Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost: async (topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost', 'topicId', topicId)
            // verify required parameter 'traversalDirection' is not null or undefined
            assertParamExists('fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost', 'traversalDirection', traversalDirection)
            // verify required parameter 'pathsPayloadTyped' is not null or undefined
            assertParamExists('fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost', 'pathsPayloadTyped', pathsPayloadTyped)
            const localVarPath = `/v1/soh/stat_relationships/{topic_id}/paths/{traversal_direction}`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)))
                .replace(`{${"traversal_direction"}}`, encodeURIComponent(String(traversalDirection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pathsPayloadTyped, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health data.
         * @summary Fetch Topics
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTopicsV1SohTopicsGet: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('fetchTopicsV1SohTopicsGet', 'query', query)
            const localVarPath = `/v1/soh/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health findings and related study if doi provided.
         * @summary Get List Of Soh Findings
         * @param {string} [doi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSohFindingsV1SohFindingsLogGet: async (doi?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/soh/findings-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health summary.
         * @summary Get Relationship Summary Between Two Topics.
         * @param {string} topic1Id 
         * @param {string} topic2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet: async (topic1Id: string, topic2Id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic1Id' is not null or undefined
            assertParamExists('getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet', 'topic1Id', topic1Id)
            // verify required parameter 'topic2Id' is not null or undefined
            assertParamExists('getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet', 'topic2Id', topic2Id)
            const localVarPath = `/v1/soh/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topic1Id !== undefined) {
                localVarQueryParameter['topic_1_id'] = topic1Id;
            }

            if (topic2Id !== undefined) {
                localVarQueryParameter['topic_2_id'] = topic2Id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health data.
         * @summary Get Soh Evidence Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohEvidenceMetadataV1SohEvidencesPost: async (sohIn: SohIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sohIn' is not null or undefined
            assertParamExists('getSohEvidenceMetadataV1SohEvidencesPost', 'sohIn', sohIn)
            const localVarPath = `/v1/soh/evidences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sohIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health data.
         * @summary Get Soh Graph Metadata
         * @param {number} [limit] Number of relationships to return.
         * @param {boolean} [clearCache] Clear cache and fetch new graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohGraphMetadataV1SohGraphGet: async (limit?: number, clearCache?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/soh/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (clearCache !== undefined) {
                localVarQueryParameter['clear_cache'] = clearCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system of health data.
         * @summary Get Soh Of Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohOfMetadataV1SohFindingsPost: async (sohIn: SohIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sohIn' is not null or undefined
            assertParamExists('getSohOfMetadataV1SohFindingsPost', 'sohIn', sohIn)
            const localVarPath = `/v1/soh/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sohIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SohApi - functional programming interface
 * @export
 */
export const SohApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SohApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch graph.
         * @summary Fetch Graph Time Series Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphTimeSeriesOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch graph.
         * @summary Fetch Mech Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch mediators.
         * @summary Fetch Mech Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(topicId, targetTopicId, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch paths.
         * @summary Fetch Mech Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch graph.
         * @summary Fetch Stat Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch mediators.
         * @summary Fetch Stat Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(topicId, targetTopicId, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch paths.
         * @summary Fetch Stat Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health data.
         * @summary Fetch Topics
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTopicsV1SohTopicsGet(query: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SohServiceClientModelsTopicNodeTopicNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchTopicsV1SohTopicsGet(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health findings and related study if doi provided.
         * @summary Get List Of Soh Findings
         * @param {string} [doi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfSohFindingsV1SohFindingsLogGet(doi?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindingsLogOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfSohFindingsV1SohFindingsLogGet(doi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health summary.
         * @summary Get Relationship Summary Between Two Topics.
         * @param {string} topic1Id 
         * @param {string} topic2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(topic1Id: string, topic2Id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(topic1Id, topic2Id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health data.
         * @summary Get Soh Evidence Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSohEvidenceMetadataV1SohEvidencesPost(sohIn: SohIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SohEvidenceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSohEvidenceMetadataV1SohEvidencesPost(sohIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health data.
         * @summary Get Soh Graph Metadata
         * @param {number} [limit] Number of relationships to return.
         * @param {boolean} [clearCache] Clear cache and fetch new graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSohGraphMetadataV1SohGraphGet(limit?: number, clearCache?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSohGraphMetadataV1SohGraphGet(limit, clearCache, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system of health data.
         * @summary Get Soh Of Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSohOfMetadataV1SohFindingsPost(sohIn: SohIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SohOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSohOfMetadataV1SohFindingsPost(sohIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SohApi - factory interface
 * @export
 */
export const SohApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SohApiFp(configuration)
    return {
        /**
         * Fetch graph.
         * @summary Fetch Graph Time Series Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options?: any): AxiosPromise<GraphTimeSeriesOut> {
            return localVarFp.fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch graph.
         * @summary Fetch Mech Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<GraphOut> {
            return localVarFp.fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch mediators.
         * @summary Fetch Mech Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<PathsOut> {
            return localVarFp.fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(topicId, targetTopicId, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch paths.
         * @summary Fetch Mech Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<PathsOut> {
            return localVarFp.fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch graph.
         * @summary Fetch Stat Graph
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<GraphOut> {
            return localVarFp.fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch mediators.
         * @summary Fetch Stat Mediators
         * @param {string} topicId 
         * @param {string} targetTopicId 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(topicId: string, targetTopicId: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<PathsOut> {
            return localVarFp.fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(topicId, targetTopicId, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch paths.
         * @summary Fetch Stat Paths
         * @param {string} topicId 
         * @param {string} traversalDirection 
         * @param {PathsPayloadTyped} pathsPayloadTyped 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(topicId: string, traversalDirection: string, pathsPayloadTyped: PathsPayloadTyped, options?: any): AxiosPromise<PathsOut> {
            return localVarFp.fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(topicId, traversalDirection, pathsPayloadTyped, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health data.
         * @summary Fetch Topics
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTopicsV1SohTopicsGet(query: string, options?: any): AxiosPromise<Array<SohServiceClientModelsTopicNodeTopicNode>> {
            return localVarFp.fetchTopicsV1SohTopicsGet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health findings and related study if doi provided.
         * @summary Get List Of Soh Findings
         * @param {string} [doi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSohFindingsV1SohFindingsLogGet(doi?: string, options?: any): AxiosPromise<FindingsLogOut> {
            return localVarFp.getListOfSohFindingsV1SohFindingsLogGet(doi, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health summary.
         * @summary Get Relationship Summary Between Two Topics.
         * @param {string} topic1Id 
         * @param {string} topic2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(topic1Id: string, topic2Id: string, options?: any): AxiosPromise<string> {
            return localVarFp.getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(topic1Id, topic2Id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health data.
         * @summary Get Soh Evidence Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohEvidenceMetadataV1SohEvidencesPost(sohIn: SohIn, options?: any): AxiosPromise<SohEvidenceOut> {
            return localVarFp.getSohEvidenceMetadataV1SohEvidencesPost(sohIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health data.
         * @summary Get Soh Graph Metadata
         * @param {number} [limit] Number of relationships to return.
         * @param {boolean} [clearCache] Clear cache and fetch new graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohGraphMetadataV1SohGraphGet(limit?: number, clearCache?: boolean, options?: any): AxiosPromise<GraphOut> {
            return localVarFp.getSohGraphMetadataV1SohGraphGet(limit, clearCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system of health data.
         * @summary Get Soh Of Metadata
         * @param {SohIn} sohIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSohOfMetadataV1SohFindingsPost(sohIn: SohIn, options?: any): AxiosPromise<SohOut> {
            return localVarFp.getSohOfMetadataV1SohFindingsPost(sohIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost operation in SohApi.
 * @export
 * @interface SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPostRequest
 */
export interface SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly traversalDirection: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost operation in SohApi.
 * @export
 * @interface SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPostRequest
 */
export interface SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost
     */
    readonly targetTopicId: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost operation in SohApi.
 * @export
 * @interface SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPostRequest
 */
export interface SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly traversalDirection: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost operation in SohApi.
 * @export
 * @interface SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPostRequest
 */
export interface SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly traversalDirection: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost operation in SohApi.
 * @export
 * @interface SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPostRequest
 */
export interface SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost
     */
    readonly targetTopicId: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost operation in SohApi.
 * @export
 * @interface SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPostRequest
 */
export interface SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly topicId: string

    /**
     * 
     * @type {string}
     * @memberof SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly traversalDirection: string

    /**
     * 
     * @type {PathsPayloadTyped}
     * @memberof SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost
     */
    readonly pathsPayloadTyped: PathsPayloadTyped
}

/**
 * Request parameters for fetchTopicsV1SohTopicsGet operation in SohApi.
 * @export
 * @interface SohApiFetchTopicsV1SohTopicsGetRequest
 */
export interface SohApiFetchTopicsV1SohTopicsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiFetchTopicsV1SohTopicsGet
     */
    readonly query: string
}

/**
 * Request parameters for getListOfSohFindingsV1SohFindingsLogGet operation in SohApi.
 * @export
 * @interface SohApiGetListOfSohFindingsV1SohFindingsLogGetRequest
 */
export interface SohApiGetListOfSohFindingsV1SohFindingsLogGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiGetListOfSohFindingsV1SohFindingsLogGet
     */
    readonly doi?: string
}

/**
 * Request parameters for getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet operation in SohApi.
 * @export
 * @interface SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGetRequest
 */
export interface SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet
     */
    readonly topic1Id: string

    /**
     * 
     * @type {string}
     * @memberof SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet
     */
    readonly topic2Id: string
}

/**
 * Request parameters for getSohEvidenceMetadataV1SohEvidencesPost operation in SohApi.
 * @export
 * @interface SohApiGetSohEvidenceMetadataV1SohEvidencesPostRequest
 */
export interface SohApiGetSohEvidenceMetadataV1SohEvidencesPostRequest {
    /**
     * 
     * @type {SohIn}
     * @memberof SohApiGetSohEvidenceMetadataV1SohEvidencesPost
     */
    readonly sohIn: SohIn
}

/**
 * Request parameters for getSohGraphMetadataV1SohGraphGet operation in SohApi.
 * @export
 * @interface SohApiGetSohGraphMetadataV1SohGraphGetRequest
 */
export interface SohApiGetSohGraphMetadataV1SohGraphGetRequest {
    /**
     * Number of relationships to return.
     * @type {number}
     * @memberof SohApiGetSohGraphMetadataV1SohGraphGet
     */
    readonly limit?: number

    /**
     * Clear cache and fetch new graph.
     * @type {boolean}
     * @memberof SohApiGetSohGraphMetadataV1SohGraphGet
     */
    readonly clearCache?: boolean
}

/**
 * Request parameters for getSohOfMetadataV1SohFindingsPost operation in SohApi.
 * @export
 * @interface SohApiGetSohOfMetadataV1SohFindingsPostRequest
 */
export interface SohApiGetSohOfMetadataV1SohFindingsPostRequest {
    /**
     * 
     * @type {SohIn}
     * @memberof SohApiGetSohOfMetadataV1SohFindingsPost
     */
    readonly sohIn: SohIn
}

/**
 * SohApi - object-oriented interface
 * @export
 * @class SohApi
 * @extends {BaseAPI}
 */
export class SohApi extends BaseAPI {
    /**
     * Fetch graph.
     * @summary Fetch Graph Time Series Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchGraphTimeSeriesDataV1SohMetricsTimeSeriesPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch graph.
     * @summary Fetch Mech Graph
     * @param {SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(requestParameters: SohApiFetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchMechGraphV1SohMechRelationshipsTopicIdGraphTraversalDirectionPost(requestParameters.topicId, requestParameters.traversalDirection, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch mediators.
     * @summary Fetch Mech Mediators
     * @param {SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(requestParameters: SohApiFetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchMechMediatorsV1SohMechRelationshipsTopicIdPathsMediatorsPost(requestParameters.topicId, requestParameters.targetTopicId, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch paths.
     * @summary Fetch Mech Paths
     * @param {SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(requestParameters: SohApiFetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchMechPathsV1SohMechRelationshipsTopicIdPathsTraversalDirectionPost(requestParameters.topicId, requestParameters.traversalDirection, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch graph.
     * @summary Fetch Stat Graph
     * @param {SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(requestParameters: SohApiFetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchStatGraphV1SohStatRelationshipsTopicIdGraphTraversalDirectionPost(requestParameters.topicId, requestParameters.traversalDirection, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch mediators.
     * @summary Fetch Stat Mediators
     * @param {SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(requestParameters: SohApiFetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchStatMediatorsV1SohStatRelationshipsTopicIdPathsMediatorsPost(requestParameters.topicId, requestParameters.targetTopicId, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch paths.
     * @summary Fetch Stat Paths
     * @param {SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(requestParameters: SohApiFetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchStatPathsV1SohStatRelationshipsTopicIdPathsTraversalDirectionPost(requestParameters.topicId, requestParameters.traversalDirection, requestParameters.pathsPayloadTyped, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health data.
     * @summary Fetch Topics
     * @param {SohApiFetchTopicsV1SohTopicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public fetchTopicsV1SohTopicsGet(requestParameters: SohApiFetchTopicsV1SohTopicsGetRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).fetchTopicsV1SohTopicsGet(requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health findings and related study if doi provided.
     * @summary Get List Of Soh Findings
     * @param {SohApiGetListOfSohFindingsV1SohFindingsLogGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public getListOfSohFindingsV1SohFindingsLogGet(requestParameters: SohApiGetListOfSohFindingsV1SohFindingsLogGetRequest = {}, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).getListOfSohFindingsV1SohFindingsLogGet(requestParameters.doi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health summary.
     * @summary Get Relationship Summary Between Two Topics.
     * @param {SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(requestParameters: SohApiGetRelationshipSummaryBetweenTwoTopicsV1SohSummaryGetRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).getRelationshipSummaryBetweenTwoTopicsV1SohSummaryGet(requestParameters.topic1Id, requestParameters.topic2Id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health data.
     * @summary Get Soh Evidence Metadata
     * @param {SohApiGetSohEvidenceMetadataV1SohEvidencesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public getSohEvidenceMetadataV1SohEvidencesPost(requestParameters: SohApiGetSohEvidenceMetadataV1SohEvidencesPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).getSohEvidenceMetadataV1SohEvidencesPost(requestParameters.sohIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health data.
     * @summary Get Soh Graph Metadata
     * @param {SohApiGetSohGraphMetadataV1SohGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public getSohGraphMetadataV1SohGraphGet(requestParameters: SohApiGetSohGraphMetadataV1SohGraphGetRequest = {}, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).getSohGraphMetadataV1SohGraphGet(requestParameters.limit, requestParameters.clearCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system of health data.
     * @summary Get Soh Of Metadata
     * @param {SohApiGetSohOfMetadataV1SohFindingsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SohApi
     */
    public getSohOfMetadataV1SohFindingsPost(requestParameters: SohApiGetSohOfMetadataV1SohFindingsPostRequest, options?: AxiosRequestConfig) {
        return SohApiFp(this.configuration).getSohOfMetadataV1SohFindingsPost(requestParameters.sohIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SsoApi - axios parameter creator
 * @export
 */
export const SsoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviderNameV1IdpNameEmailGet: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getIdentityProviderNameV1IdpNameEmailGet', 'email', email)
            const localVarPath = `/v1/idp_name/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsoApi - functional programming interface
 * @export
 */
export const SsoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SsoApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProviderNameV1IdpNameEmailGet(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviderNameOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProviderNameV1IdpNameEmailGet(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SsoApi - factory interface
 * @export
 */
export const SsoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SsoApiFp(configuration)
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviderNameV1IdpNameEmailGet(email: string, options?: any): AxiosPromise<IdentityProviderNameOut> {
            return localVarFp.getIdentityProviderNameV1IdpNameEmailGet(email, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityProviderNameV1IdpNameEmailGet operation in SsoApi.
 * @export
 * @interface SsoApiGetIdentityProviderNameV1IdpNameEmailGetRequest
 */
export interface SsoApiGetIdentityProviderNameV1IdpNameEmailGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SsoApiGetIdentityProviderNameV1IdpNameEmailGet
     */
    readonly email: string
}

/**
 * SsoApi - object-oriented interface
 * @export
 * @class SsoApi
 * @extends {BaseAPI}
 */
export class SsoApi extends BaseAPI {
    /**
     * Get Identity Provider name for given email domain.
     * @summary Get Identity Provider Name
     * @param {SsoApiGetIdentityProviderNameV1IdpNameEmailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public getIdentityProviderNameV1IdpNameEmailGet(requestParameters: SsoApiGetIdentityProviderNameV1IdpNameEmailGetRequest, options?: AxiosRequestConfig) {
        return SsoApiFp(this.configuration).getIdentityProviderNameV1IdpNameEmailGet(requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId 
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost: async (subscriptionId: string, addSubscriptionSeatIn: AddSubscriptionSeatIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost', 'subscriptionId', subscriptionId)
            // verify required parameter 'addSubscriptionSeatIn' is not null or undefined
            assertParamExists('addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost', 'addSubscriptionSeatIn', addSubscriptionSeatIn)
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSubscriptionSeatIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSubscriptionV1StripeSubscriptionManagePost: async (domainCallback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stripe/subscription-manage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (domainCallback !== undefined) {
                localVarQueryParameter['domain_callback'] = domainCallback;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete: async (email: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete', 'email', email)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete', 'subscriptionId', subscriptionId)
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId 
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId: string, addSubscriptionSeatIn: AddSubscriptionSeatIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionSeats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageSubscriptionV1StripeSubscriptionManagePost(domainCallback?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeSessionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId 
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId: string, addSubscriptionSeatIn: AddSubscriptionSeatIn, options?: any): AxiosPromise<boolean> {
            return localVarFp.addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId: string, options?: any): AxiosPromise<SubscriptionSeats> {
            return localVarFp.getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSubscriptionV1StripeSubscriptionManagePost(domainCallback?: string, options?: any): AxiosPromise<StripeSessionOut> {
            return localVarFp.manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email: string, subscriptionId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost operation in StripeApi.
 * @export
 * @interface StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPostRequest
 */
export interface StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost
     */
    readonly subscriptionId: string

    /**
     * 
     * @type {AddSubscriptionSeatIn}
     * @memberof StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost
     */
    readonly addSubscriptionSeatIn: AddSubscriptionSeatIn
}

/**
 * Request parameters for getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet operation in StripeApi.
 * @export
 * @interface StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGetRequest
 */
export interface StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet
     */
    readonly subscriptionId: string
}

/**
 * Request parameters for manageSubscriptionV1StripeSubscriptionManagePost operation in StripeApi.
 * @export
 * @interface StripeApiManageSubscriptionV1StripeSubscriptionManagePostRequest
 */
export interface StripeApiManageSubscriptionV1StripeSubscriptionManagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiManageSubscriptionV1StripeSubscriptionManagePost
     */
    readonly domainCallback?: string
}

/**
 * Request parameters for removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete operation in StripeApi.
 * @export
 * @interface StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDeleteRequest
 */
export interface StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete
     */
    readonly subscriptionId: string
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * Add subscription seats.
     * @summary Add Subscription Seats
     * @param {StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(requestParameters: StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPostRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(requestParameters.subscriptionId, requestParameters.addSubscriptionSeatIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get subscription seats.
     * @summary Get Subscription Seats
     * @param {StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(requestParameters: StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGetRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(requestParameters.subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start stripe checkout session.
     * @summary Manage Subscription
     * @param {StripeApiManageSubscriptionV1StripeSubscriptionManagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public manageSubscriptionV1StripeSubscriptionManagePost(requestParameters: StripeApiManageSubscriptionV1StripeSubscriptionManagePostRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).manageSubscriptionV1StripeSubscriptionManagePost(requestParameters.domainCallback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove subscription seat.
     * @summary Remove Subscription Seat
     * @param {StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(requestParameters: StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDeleteRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(requestParameters.email, requestParameters.subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudyMetadataApi - axios parameter creator
 * @export
 */
export const StudyMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost: async (studyMetadataIn: StudyMetadataIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyMetadataIn' is not null or undefined
            assertParamExists('getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost', 'studyMetadataIn', studyMetadataIn)
            const localVarPath = `/v1/study-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyMetadataIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost: async (studyMetadataIn: StudyMetadataIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyMetadataIn' is not null or undefined
            assertParamExists('getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost', 'studyMetadataIn', studyMetadataIn)
            const localVarPath = `/v1/study-metadata/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyMetadataIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyMetadataApi - functional programming interface
 * @export
 */
export const StudyMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn: StudyMetadataIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyMetadataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn: StudyMetadataIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyMetadataRDBOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudyMetadataApi - factory interface
 * @export
 */
export const StudyMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyMetadataApiFp(configuration)
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn: StudyMetadataIn, options?: any): AxiosPromise<StudyMetadataOut> {
            return localVarFp.getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn: StudyMetadataIn, options?: any): AxiosPromise<StudyMetadataRDBOut> {
            return localVarFp.getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost operation in StudyMetadataApi.
 * @export
 * @interface StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPostRequest
 */
export interface StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPostRequest {
    /**
     * 
     * @type {StudyMetadataIn}
     * @memberof StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost
     */
    readonly studyMetadataIn: StudyMetadataIn
}

/**
 * Request parameters for getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost operation in StudyMetadataApi.
 * @export
 * @interface StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPostRequest
 */
export interface StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPostRequest {
    /**
     * 
     * @type {StudyMetadataIn}
     * @memberof StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost
     */
    readonly studyMetadataIn: StudyMetadataIn
}

/**
 * StudyMetadataApi - object-oriented interface
 * @export
 * @class StudyMetadataApi
 * @extends {BaseAPI}
 */
export class StudyMetadataApi extends BaseAPI {
    /**
     * Get study metadata from OpenAlex and DynamoDB via pmids.
     * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
     * @param {StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMetadataApi
     */
    public getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(requestParameters: StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPostRequest, options?: AxiosRequestConfig) {
        return StudyMetadataApiFp(this.configuration).getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(requestParameters.studyMetadataIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get study metadata from SystemRDB via pmids.
     * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
     * @param {StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMetadataApi
     */
    public getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(requestParameters: StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPostRequest, options?: AxiosRequestConfig) {
        return StudyMetadataApiFp(this.configuration).getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(requestParameters.studyMetadataIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemGraphApi - axios parameter creator
 * @export
 */
export const SystemGraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownstreamEndpointV1SystemGraphPathsDownstreamGet: async (node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getDownstreamEndpointV1SystemGraphPathsDownstreamGet', 'node', node)
            const localVarPath = `/v1/system_graph/paths/downstream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (nHops !== undefined) {
                localVarQueryParameter['n_hops'] = nHops;
            }

            if (additionalNodes) {
                localVarQueryParameter['additional_nodes'] = additionalNodes;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediatorsEndpointV1SystemGraphPathsMediatorsGet: async (source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getMediatorsEndpointV1SystemGraphPathsMediatorsGet', 'source', source)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getMediatorsEndpointV1SystemGraphPathsMediatorsGet', 'target', target)
            const localVarPath = `/v1/system_graph/paths/mediators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (additionalSources) {
                localVarQueryParameter['additional_sources'] = additionalSources;
            }

            if (additionalTargets) {
                localVarQueryParameter['additional_targets'] = additionalTargets;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet: async (topicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet', 'topicId', topicId)
            const localVarPath = `/v1/system_graph/topic/{topic_id}/one_degree`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipEndpointV1SystemGraphPathsRelationshipGet: async (source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getRelationshipEndpointV1SystemGraphPathsRelationshipGet', 'source', source)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getRelationshipEndpointV1SystemGraphPathsRelationshipGet', 'target', target)
            const localVarPath = `/v1/system_graph/paths/relationship`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (additionalSources) {
                localVarQueryParameter['additional_sources'] = additionalSources;
            }

            if (additionalTargets) {
                localVarQueryParameter['additional_targets'] = additionalTargets;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphEndpointV1SystemGraphSemanticGraphGet: async (topic1?: string, topic2?: string, ids1?: Array<string>, ids2?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/system_graph/semantic_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topic1 !== undefined) {
                localVarQueryParameter['topic_1'] = topic1;
            }

            if (topic2 !== undefined) {
                localVarQueryParameter['topic_2'] = topic2;
            }

            if (ids1) {
                localVarQueryParameter['ids_1'] = ids1;
            }

            if (ids2) {
                localVarQueryParameter['ids_2'] = ids2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet: async (topicName?: string, topicIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/system_graph/semantic_topic_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topicName !== undefined) {
                localVarQueryParameter['topic_name'] = topicName;
            }

            if (topicIds) {
                localVarQueryParameter['topic_ids'] = topicIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet: async (source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet', 'source', source)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet', 'target', target)
            const localVarPath = `/v1/system_graph/paths/shared-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (additionalSources) {
                localVarQueryParameter['additional_sources'] = additionalSources;
            }

            if (additionalTargets) {
                localVarQueryParameter['additional_targets'] = additionalTargets;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet: async (source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet', 'source', source)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet', 'target', target)
            const localVarPath = `/v1/system_graph/paths/shared-targets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (additionalSources) {
                localVarQueryParameter['additional_sources'] = additionalSources;
            }

            if (additionalTargets) {
                localVarQueryParameter['additional_targets'] = additionalTargets;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemGraphEndpointV1SystemGraphSystemGraphGet: async (numRelationships?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/system_graph/system_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (numRelationships !== undefined) {
                localVarQueryParameter['num_relationships'] = numRelationships;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet: async (topic1: string, ids1: Array<string>, topic2?: string, ids2?: Array<string>, pageSize?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic1' is not null or undefined
            assertParamExists('getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet', 'topic1', topic1)
            // verify required parameter 'ids1' is not null or undefined
            assertParamExists('getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet', 'ids1', ids1)
            const localVarPath = `/v1/system_graph/topological_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topic1 !== undefined) {
                localVarQueryParameter['topic_1'] = topic1;
            }

            if (topic2 !== undefined) {
                localVarQueryParameter['topic_2'] = topic2;
            }

            if (ids1) {
                localVarQueryParameter['ids_1'] = ids1;
            }

            if (ids2) {
                localVarQueryParameter['ids_2'] = ids2;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relationship path.
         * @summary Get Two Hop Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet: async (source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet', 'source', source)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet', 'target', target)
            const localVarPath = `/v1/system_graph/paths/two-hop-mediators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (additionalSources) {
                localVarQueryParameter['additional_sources'] = additionalSources;
            }

            if (additionalTargets) {
                localVarQueryParameter['additional_targets'] = additionalTargets;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpstreamEndpointV1SystemGraphPathsUpstreamGet: async (node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getUpstreamEndpointV1SystemGraphPathsUpstreamGet', 'node', node)
            const localVarPath = `/v1/system_graph/paths/upstream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (nHops !== undefined) {
                localVarQueryParameter['n_hops'] = nHops;
            }

            if (additionalNodes) {
                localVarQueryParameter['additional_nodes'] = additionalNodes;
            }

            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }

            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }

            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search topics.
         * @summary Search Topics Endpoint
         * @param {string} q Search query
         * @param {Array<string>} [subgraphTopics] Topic ids in subgraph
         * @param {number} [subgraphDepth] Depth of subgraph
         * @param {SearchType} [searchType] Search type (semantic or keyword)
         * @param {number} [autocut] Autocut for semantic search
         * @param {number} [limit] Limit for semantic search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopicsEndpointV1SystemGraphSearchGet: async (q: string, subgraphTopics?: Array<string>, subgraphDepth?: number, searchType?: SearchType, autocut?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchTopicsEndpointV1SystemGraphSearchGet', 'q', q)
            const localVarPath = `/v1/system_graph/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (subgraphTopics) {
                localVarQueryParameter['subgraph_topics'] = subgraphTopics;
            }

            if (subgraphDepth !== undefined) {
                localVarQueryParameter['subgraph_depth'] = subgraphDepth;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (autocut !== undefined) {
                localVarQueryParameter['autocut'] = autocut;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemGraphApi - functional programming interface
 * @export
 */
export const SystemGraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemGraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, additionalNodes, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptRelationshipsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1?: string, topic2?: string, ids1?: Array<string>, ids2?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName?: string, topicIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1: string, ids1: Array<string>, topic2?: string, ids2?: Array<string>, pageSize?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicCategories>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get relationship path.
         * @summary Get Two Hop Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPathsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, additionalNodes, relationshipTypes, includeNonSignificant, semanticTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search topics.
         * @summary Search Topics Endpoint
         * @param {string} q Search query
         * @param {Array<string>} [subgraphTopics] Topic ids in subgraph
         * @param {number} [subgraphDepth] Depth of subgraph
         * @param {SearchType} [searchType] Search type (semantic or keyword)
         * @param {number} [autocut] Autocut for semantic search
         * @param {number} [limit] Limit for semantic search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTopicsEndpointV1SystemGraphSearchGet(q: string, subgraphTopics?: Array<string>, subgraphDepth?: number, searchType?: SearchType, autocut?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTopicsEndpointV1SystemGraphSearchGet(q, subgraphTopics, subgraphDepth, searchType, autocut, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemGraphApi - factory interface
 * @export
 */
export const SystemGraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemGraphApiFp(configuration)
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, additionalNodes, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId: string, options?: any): AxiosPromise<ConceptRelationshipsOut> {
            return localVarFp.getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1?: string, topic2?: string, ids1?: Array<string>, ids2?: Array<string>, options?: any): AxiosPromise<GraphData> {
            return localVarFp.getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName?: string, topicIds?: Array<string>, options?: any): AxiosPromise<GraphData> {
            return localVarFp.getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships?: number, options?: any): AxiosPromise<GraphData> {
            return localVarFp.getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1: string, ids1: Array<string>, topic2?: string, ids2?: Array<string>, pageSize?: number, offset?: number, options?: any): AxiosPromise<TopicCategories> {
            return localVarFp.getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Two Hop Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {Array<string>} [additionalSources] Additional sources
         * @param {Array<string>} [additionalTargets] Additional targets
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(source: string, target: string, page?: number, pageSize?: number, additionalSources?: Array<string>, additionalTargets?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(source, target, page, pageSize, additionalSources, additionalTargets, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {Array<string>} [additionalNodes] Additional nodes
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node: string, page?: number, pageSize?: number, nHops?: number, additionalNodes?: Array<string>, relationshipTypes?: string, includeNonSignificant?: boolean, semanticTypes?: string, options?: any): AxiosPromise<MapPathsOut> {
            return localVarFp.getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, additionalNodes, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Search topics.
         * @summary Search Topics Endpoint
         * @param {string} q Search query
         * @param {Array<string>} [subgraphTopics] Topic ids in subgraph
         * @param {number} [subgraphDepth] Depth of subgraph
         * @param {SearchType} [searchType] Search type (semantic or keyword)
         * @param {number} [autocut] Autocut for semantic search
         * @param {number} [limit] Limit for semantic search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopicsEndpointV1SystemGraphSearchGet(q: string, subgraphTopics?: Array<string>, subgraphDepth?: number, searchType?: SearchType, autocut?: number, limit?: number, options?: any): AxiosPromise<Array<TopicOut>> {
            return localVarFp.searchTopicsEndpointV1SystemGraphSearchGet(q, subgraphTopics, subgraphDepth, searchType, autocut, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDownstreamEndpointV1SystemGraphPathsDownstreamGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGetRequest
 */
export interface SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGetRequest {
    /**
     * System ID of topic node
     * @type {string}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly node: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly pageSize?: number

    /**
     * Number of hops
     * @type {number}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly nHops?: number

    /**
     * Additional nodes
     * @type {Array<string>}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly additionalNodes?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getMediatorsEndpointV1SystemGraphPathsMediatorsGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGetRequest
 */
export interface SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGetRequest {
    /**
     * System ID of source
     * @type {string}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly source: string

    /**
     * System ID of target
     * @type {string}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly target: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly pageSize?: number

    /**
     * Additional sources
     * @type {Array<string>}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly additionalSources?: Array<string>

    /**
     * Additional targets
     * @type {Array<string>}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly additionalTargets?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGetRequest
 */
export interface SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet
     */
    readonly topicId: string
}

/**
 * Request parameters for getRelationshipEndpointV1SystemGraphPathsRelationshipGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGetRequest
 */
export interface SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGetRequest {
    /**
     * System ID of source
     * @type {string}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly source: string

    /**
     * System ID of target
     * @type {string}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly target: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly pageSize?: number

    /**
     * Additional sources
     * @type {Array<string>}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly additionalSources?: Array<string>

    /**
     * Additional targets
     * @type {Array<string>}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly additionalTargets?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getSemanticGraphEndpointV1SystemGraphSemanticGraphGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGetRequest
 */
export interface SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGetRequest {
    /**
     * Topic 1
     * @type {string}
     * @memberof SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGet
     */
    readonly topic1?: string

    /**
     * Topic 2
     * @type {string}
     * @memberof SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGet
     */
    readonly topic2?: string

    /**
     * Topic 1 ids
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGet
     */
    readonly ids1?: Array<string>

    /**
     * Topic 2 ids
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGet
     */
    readonly ids2?: Array<string>
}

/**
 * Request parameters for getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGetRequest
 */
export interface SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGetRequest {
    /**
     * Topic name
     * @type {string}
     * @memberof SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet
     */
    readonly topicName?: string

    /**
     * Topic ids
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet
     */
    readonly topicIds?: Array<string>
}

/**
 * Request parameters for getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGetRequest
 */
export interface SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGetRequest {
    /**
     * System ID of source
     * @type {string}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly source: string

    /**
     * System ID of target
     * @type {string}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly target: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly pageSize?: number

    /**
     * Additional sources
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly additionalSources?: Array<string>

    /**
     * Additional targets
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly additionalTargets?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGetRequest
 */
export interface SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGetRequest {
    /**
     * System ID of source
     * @type {string}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly source: string

    /**
     * System ID of target
     * @type {string}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly target: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly pageSize?: number

    /**
     * Additional sources
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly additionalSources?: Array<string>

    /**
     * Additional targets
     * @type {Array<string>}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly additionalTargets?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getSystemGraphEndpointV1SystemGraphSystemGraphGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGetRequest
 */
export interface SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGetRequest {
    /**
     * Number of relationships to return.
     * @type {number}
     * @memberof SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGet
     */
    readonly numRelationships?: number
}

/**
 * Request parameters for getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGetRequest
 */
export interface SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGetRequest {
    /**
     * Topic 1
     * @type {string}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly topic1: string

    /**
     * Topic 1 ids
     * @type {Array<string>}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly ids1: Array<string>

    /**
     * Topic 2
     * @type {string}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly topic2?: string

    /**
     * Topic 2 ids
     * @type {Array<string>}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly ids2?: Array<string>

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly pageSize?: number

    /**
     * Offset
     * @type {number}
     * @memberof SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet
     */
    readonly offset?: number
}

/**
 * Request parameters for getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGetRequest
 */
export interface SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGetRequest {
    /**
     * System ID of source
     * @type {string}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly source: string

    /**
     * System ID of target
     * @type {string}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly target: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly pageSize?: number

    /**
     * Additional sources
     * @type {Array<string>}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly additionalSources?: Array<string>

    /**
     * Additional targets
     * @type {Array<string>}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly additionalTargets?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for getUpstreamEndpointV1SystemGraphPathsUpstreamGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGetRequest
 */
export interface SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGetRequest {
    /**
     * System ID of topic node
     * @type {string}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly node: string

    /**
     * Page number
     * @type {number}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly page?: number

    /**
     * Page size
     * @type {number}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly pageSize?: number

    /**
     * Number of hops
     * @type {number}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly nHops?: number

    /**
     * Additional nodes
     * @type {Array<string>}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly additionalNodes?: Array<string>

    /**
     * Comma separated list of relationship types
     * @type {string}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly relationshipTypes?: string

    /**
     * Significant relationships only
     * @type {boolean}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly includeNonSignificant?: boolean

    /**
     * Comma separated list of semantic_types
     * @type {string}
     * @memberof SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGet
     */
    readonly semanticTypes?: string
}

/**
 * Request parameters for searchTopicsEndpointV1SystemGraphSearchGet operation in SystemGraphApi.
 * @export
 * @interface SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGetRequest
 */
export interface SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGetRequest {
    /**
     * Search query
     * @type {string}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly q: string

    /**
     * Topic ids in subgraph
     * @type {Array<string>}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly subgraphTopics?: Array<string>

    /**
     * Depth of subgraph
     * @type {number}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly subgraphDepth?: number

    /**
     * Search type (semantic or keyword)
     * @type {SearchType}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly searchType?: SearchType

    /**
     * Autocut for semantic search
     * @type {number}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly autocut?: number

    /**
     * Limit for semantic search
     * @type {number}
     * @memberof SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGet
     */
    readonly limit?: number
}

/**
 * SystemGraphApi - object-oriented interface
 * @export
 * @class SystemGraphApi
 * @extends {BaseAPI}
 */
export class SystemGraphApi extends BaseAPI {
    /**
     * Get downstream paths.
     * @summary Get Downstream Endpoint
     * @param {SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getDownstreamEndpointV1SystemGraphPathsDownstreamGet(requestParameters: SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getDownstreamEndpointV1SystemGraphPathsDownstreamGet(requestParameters.node, requestParameters.page, requestParameters.pageSize, requestParameters.nHops, requestParameters.additionalNodes, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get relationship path.
     * @summary Get Mediators Endpoint
     * @param {SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getMediatorsEndpointV1SystemGraphPathsMediatorsGet(requestParameters: SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getMediatorsEndpointV1SystemGraphPathsMediatorsGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.additionalSources, requestParameters.additionalTargets, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system graph from the database.
     * @summary Get One Degree From Topic
     * @param {SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(requestParameters: SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(requestParameters.topicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get relationship path.
     * @summary Get Relationship Endpoint
     * @param {SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getRelationshipEndpointV1SystemGraphPathsRelationshipGet(requestParameters: SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getRelationshipEndpointV1SystemGraphPathsRelationshipGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.additionalSources, requestParameters.additionalTargets, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch semantic graph.
     * @summary Get Semantic Graph Endpoint
     * @param {SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(requestParameters: SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGetRequest = {}, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(requestParameters.topic1, requestParameters.topic2, requestParameters.ids1, requestParameters.ids2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch single topic semantic graph.
     * @summary Get Semantic Topic Graph Endpoint
     * @param {SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(requestParameters: SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGetRequest = {}, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(requestParameters.topicName, requestParameters.topicIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get relationship path.
     * @summary Get Shared Sources Endpoint
     * @param {SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(requestParameters: SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.additionalSources, requestParameters.additionalTargets, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get relationship path.
     * @summary Get Shared Targets Endpoint
     * @param {SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(requestParameters: SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.additionalSources, requestParameters.additionalTargets, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system graph from the database.
     * @summary Get System Graph Endpoint
     * @param {SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getSystemGraphEndpointV1SystemGraphSystemGraphGet(requestParameters: SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGetRequest = {}, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getSystemGraphEndpointV1SystemGraphSystemGraphGet(requestParameters.numRelationships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch semantic graph.
     * @summary Get Topological Categories Endpoint
     * @param {SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(requestParameters: SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(requestParameters.topic1, requestParameters.ids1, requestParameters.topic2, requestParameters.ids2, requestParameters.pageSize, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get relationship path.
     * @summary Get Two Hop Mediators Endpoint
     * @param {SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(requestParameters: SystemGraphApiGetTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getTwoHopMediatorsEndpointV1SystemGraphPathsTwoHopMediatorsGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.additionalSources, requestParameters.additionalTargets, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upstream paths.
     * @summary Get Upstream Endpoint
     * @param {SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public getUpstreamEndpointV1SystemGraphPathsUpstreamGet(requestParameters: SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).getUpstreamEndpointV1SystemGraphPathsUpstreamGet(requestParameters.node, requestParameters.page, requestParameters.pageSize, requestParameters.nHops, requestParameters.additionalNodes, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search topics.
     * @summary Search Topics Endpoint
     * @param {SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    public searchTopicsEndpointV1SystemGraphSearchGet(requestParameters: SystemGraphApiSearchTopicsEndpointV1SystemGraphSearchGetRequest, options?: AxiosRequestConfig) {
        return SystemGraphApiFp(this.configuration).searchTopicsEndpointV1SystemGraphSearchGet(requestParameters.q, requestParameters.subgraphTopics, requestParameters.subgraphDepth, requestParameters.searchType, requestParameters.autocut, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information for variables related to a topic.
         * @summary Get Variables Related To A Topic.
         * @param {string} topicId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesRelatedToATopicV1TopicVariablesGet: async (topicId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getVariablesRelatedToATopicV1TopicVariablesGet', 'topicId', topicId)
            const localVarPath = `/v1/topic/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information for variables related to a topic.
         * @summary Get Variables Related To A Topic.
         * @param {string} topicId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariablesRelatedToATopicV1TopicVariablesGet(topicId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicVariablesOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariablesRelatedToATopicV1TopicVariablesGet(topicId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * Get information for variables related to a topic.
         * @summary Get Variables Related To A Topic.
         * @param {string} topicId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesRelatedToATopicV1TopicVariablesGet(topicId: string, limit?: number, offset?: number, options?: any): AxiosPromise<TopicVariablesOut> {
            return localVarFp.getVariablesRelatedToATopicV1TopicVariablesGet(topicId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getVariablesRelatedToATopicV1TopicVariablesGet operation in TopicApi.
 * @export
 * @interface TopicApiGetVariablesRelatedToATopicV1TopicVariablesGetRequest
 */
export interface TopicApiGetVariablesRelatedToATopicV1TopicVariablesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicApiGetVariablesRelatedToATopicV1TopicVariablesGet
     */
    readonly topicId: string

    /**
     * 
     * @type {number}
     * @memberof TopicApiGetVariablesRelatedToATopicV1TopicVariablesGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TopicApiGetVariablesRelatedToATopicV1TopicVariablesGet
     */
    readonly offset?: number
}

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Get information for variables related to a topic.
     * @summary Get Variables Related To A Topic.
     * @param {TopicApiGetVariablesRelatedToATopicV1TopicVariablesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getVariablesRelatedToATopicV1TopicVariablesGet(requestParameters: TopicApiGetVariablesRelatedToATopicV1TopicVariablesGetRequest, options?: AxiosRequestConfig) {
        return TopicApiFp(this.configuration).getVariablesRelatedToATopicV1TopicVariablesGet(requestParameters.topicId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserByCognitoIdV1UsersPost: async (userId: string, updateProfileIn: UpdateProfileIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createAUserByCognitoIdV1UsersPost', 'userId', userId)
            // verify required parameter 'updateProfileIn' is not null or undefined
            assertParamExists('createAUserByCognitoIdV1UsersPost', 'updateProfileIn', updateProfileIn)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserFromCredentialsV1UserPost: async (userProfileIn: UserProfileIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileIn' is not null or undefined
            assertParamExists('createAUserFromCredentialsV1UserPost', 'userProfileIn', userProfileIn)
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUserV1UserGet: async (includeAvatar?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId 
         * @param {boolean} [includeAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UsersUserIdGet: async (userId: string, includeAvatar?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserV1UsersUserIdGet', 'userId', userId)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId] 
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersV1UsersGet: async (teamId?: string, email?: string, includeAvatar?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAUserByIdV1UsersUserIdPatch: async (userId: string, updateProfileIn: UpdateProfileIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateAUserByIdV1UsersUserIdPatch', 'userId', userId)
            // verify required parameter 'updateProfileIn' is not null or undefined
            assertParamExists('updateAUserByIdV1UsersUserIdPatch', 'updateProfileIn', updateProfileIn)
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthenticatedUserProfileV1UserPut: async (userProfileIn: UserProfileIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileIn' is not null or undefined
            assertParamExists('updateAuthenticatedUserProfileV1UserPut', 'userProfileIn', userProfileIn)
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAUserByCognitoIdV1UsersPost(userId: string, updateProfileIn: UpdateProfileIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPrivateProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAUserFromCredentialsV1UserPost(userProfileIn: UserProfileIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPrivateProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAUserFromCredentialsV1UserPost(userProfileIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticatedUserV1UserGet(includeAvatar?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPrivateProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedUserV1UserGet(includeAvatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId 
         * @param {boolean} [includeAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserV1UsersUserIdGet(userId: string, includeAvatar?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublicProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserV1UsersUserIdGet(userId, includeAvatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId] 
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersV1UsersGet(teamId?: string, email?: string, includeAvatar?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPublicProfileOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersV1UsersGet(teamId, email, includeAvatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAUserByIdV1UsersUserIdPatch(userId: string, updateProfileIn: UpdateProfileIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPrivateProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuthenticatedUserProfileV1UserPut(userProfileIn: UserProfileIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPrivateProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAuthenticatedUserProfileV1UserPut(userProfileIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserByCognitoIdV1UsersPost(userId: string, updateProfileIn: UpdateProfileIn, options?: any): AxiosPromise<UserPrivateProfileOut> {
            return localVarFp.createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserFromCredentialsV1UserPost(userProfileIn: UserProfileIn, options?: any): AxiosPromise<UserPrivateProfileOut> {
            return localVarFp.createAUserFromCredentialsV1UserPost(userProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUserV1UserGet(includeAvatar?: boolean, options?: any): AxiosPromise<UserPrivateProfileOut> {
            return localVarFp.getAuthenticatedUserV1UserGet(includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId 
         * @param {boolean} [includeAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UsersUserIdGet(userId: string, includeAvatar?: boolean, options?: any): AxiosPromise<UserPublicProfileOut> {
            return localVarFp.getUserV1UsersUserIdGet(userId, includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId] 
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersV1UsersGet(teamId?: string, email?: string, includeAvatar?: boolean, options?: any): AxiosPromise<Array<UserPublicProfileOut>> {
            return localVarFp.getUsersV1UsersGet(teamId, email, includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId 
         * @param {UpdateProfileIn} updateProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAUserByIdV1UsersUserIdPatch(userId: string, updateProfileIn: UpdateProfileIn, options?: any): AxiosPromise<UserPrivateProfileOut> {
            return localVarFp.updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthenticatedUserProfileV1UserPut(userProfileIn: UserProfileIn, options?: any): AxiosPromise<UserPrivateProfileOut> {
            return localVarFp.updateAuthenticatedUserProfileV1UserPut(userProfileIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAUserByCognitoIdV1UsersPost operation in UsersApi.
 * @export
 * @interface UsersApiCreateAUserByCognitoIdV1UsersPostRequest
 */
export interface UsersApiCreateAUserByCognitoIdV1UsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiCreateAUserByCognitoIdV1UsersPost
     */
    readonly userId: string

    /**
     * 
     * @type {UpdateProfileIn}
     * @memberof UsersApiCreateAUserByCognitoIdV1UsersPost
     */
    readonly updateProfileIn: UpdateProfileIn
}

/**
 * Request parameters for createAUserFromCredentialsV1UserPost operation in UsersApi.
 * @export
 * @interface UsersApiCreateAUserFromCredentialsV1UserPostRequest
 */
export interface UsersApiCreateAUserFromCredentialsV1UserPostRequest {
    /**
     * 
     * @type {UserProfileIn}
     * @memberof UsersApiCreateAUserFromCredentialsV1UserPost
     */
    readonly userProfileIn: UserProfileIn
}

/**
 * Request parameters for getAuthenticatedUserV1UserGet operation in UsersApi.
 * @export
 * @interface UsersApiGetAuthenticatedUserV1UserGetRequest
 */
export interface UsersApiGetAuthenticatedUserV1UserGetRequest {
    /**
     * Include the user\&#39;s avatar.
     * @type {boolean}
     * @memberof UsersApiGetAuthenticatedUserV1UserGet
     */
    readonly includeAvatar?: boolean
}

/**
 * Request parameters for getUserV1UsersUserIdGet operation in UsersApi.
 * @export
 * @interface UsersApiGetUserV1UsersUserIdGetRequest
 */
export interface UsersApiGetUserV1UsersUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUserV1UsersUserIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {boolean}
     * @memberof UsersApiGetUserV1UsersUserIdGet
     */
    readonly includeAvatar?: boolean
}

/**
 * Request parameters for getUsersV1UsersGet operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersV1UsersGetRequest
 */
export interface UsersApiGetUsersV1UsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersV1UsersGet
     */
    readonly teamId?: string

    /**
     * Email address
     * @type {string}
     * @memberof UsersApiGetUsersV1UsersGet
     */
    readonly email?: string

    /**
     * Include avatar
     * @type {boolean}
     * @memberof UsersApiGetUsersV1UsersGet
     */
    readonly includeAvatar?: boolean
}

/**
 * Request parameters for updateAUserByIdV1UsersUserIdPatch operation in UsersApi.
 * @export
 * @interface UsersApiUpdateAUserByIdV1UsersUserIdPatchRequest
 */
export interface UsersApiUpdateAUserByIdV1UsersUserIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUpdateAUserByIdV1UsersUserIdPatch
     */
    readonly userId: string

    /**
     * 
     * @type {UpdateProfileIn}
     * @memberof UsersApiUpdateAUserByIdV1UsersUserIdPatch
     */
    readonly updateProfileIn: UpdateProfileIn
}

/**
 * Request parameters for updateAuthenticatedUserProfileV1UserPut operation in UsersApi.
 * @export
 * @interface UsersApiUpdateAuthenticatedUserProfileV1UserPutRequest
 */
export interface UsersApiUpdateAuthenticatedUserProfileV1UserPutRequest {
    /**
     * 
     * @type {UserProfileIn}
     * @memberof UsersApiUpdateAuthenticatedUserProfileV1UserPut
     */
    readonly userProfileIn: UserProfileIn
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user.
     * @summary Create A User By Cognito Id.
     * @param {UsersApiCreateAUserByCognitoIdV1UsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createAUserByCognitoIdV1UsersPost(requestParameters: UsersApiCreateAUserByCognitoIdV1UsersPostRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createAUserByCognitoIdV1UsersPost(requestParameters.userId, requestParameters.updateProfileIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create A User From Credentials.
     * @param {UsersApiCreateAUserFromCredentialsV1UserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createAUserFromCredentialsV1UserPost(requestParameters: UsersApiCreateAUserFromCredentialsV1UserPostRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createAUserFromCredentialsV1UserPost(requestParameters.userProfileIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the authenticated user\'s profile.
     * @summary Get Authenticated User
     * @param {UsersApiGetAuthenticatedUserV1UserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAuthenticatedUserV1UserGet(requestParameters: UsersApiGetAuthenticatedUserV1UserGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAuthenticatedUserV1UserGet(requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a single user\'s public profile.
     * @summary Get User
     * @param {UsersApiGetUserV1UsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserV1UsersUserIdGet(requestParameters: UsersApiGetUserV1UsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserV1UsersUserIdGet(requestParameters.userId, requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List public profiles.
     * @summary Get Users
     * @param {UsersApiGetUsersV1UsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersV1UsersGet(requestParameters: UsersApiGetUsersV1UsersGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersV1UsersGet(requestParameters.teamId, requestParameters.email, requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Update A User By Id.
     * @param {UsersApiUpdateAUserByIdV1UsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateAUserByIdV1UsersUserIdPatch(requestParameters: UsersApiUpdateAUserByIdV1UsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateAUserByIdV1UsersUserIdPatch(requestParameters.userId, requestParameters.updateProfileIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user\'s profile.
     * @summary Update Authenticated User Profile
     * @param {UsersApiUpdateAuthenticatedUserProfileV1UserPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateAuthenticatedUserProfileV1UserPut(requestParameters: UsersApiUpdateAuthenticatedUserProfileV1UserPutRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateAuthenticatedUserProfileV1UserPut(requestParameters.userProfileIn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VariableApi - axios parameter creator
 * @export
 */
export const VariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information for variable findings.
         * @summary Get Findings Of A Variable.
         * @param {string} variableId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsOfAVariableV1VariableVariableIdFindingsGet: async (variableId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('getFindingsOfAVariableV1VariableVariableIdFindingsGet', 'variableId', variableId)
            const localVarPath = `/v1/variable/{variable_id}/findings`
                .replace(`{${"variable_id"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableApi - functional programming interface
 * @export
 */
export const VariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information for variable findings.
         * @summary Get Findings Of A Variable.
         * @param {string} variableId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindingsOfAVariableV1VariableVariableIdFindingsGet(variableId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyFindingsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindingsOfAVariableV1VariableVariableIdFindingsGet(variableId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VariableApi - factory interface
 * @export
 */
export const VariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableApiFp(configuration)
    return {
        /**
         * Get information for variable findings.
         * @summary Get Findings Of A Variable.
         * @param {string} variableId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsOfAVariableV1VariableVariableIdFindingsGet(variableId: string, limit?: number, offset?: number, options?: any): AxiosPromise<StudyFindingsOut> {
            return localVarFp.getFindingsOfAVariableV1VariableVariableIdFindingsGet(variableId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFindingsOfAVariableV1VariableVariableIdFindingsGet operation in VariableApi.
 * @export
 * @interface VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGetRequest
 */
export interface VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGet
     */
    readonly variableId: string

    /**
     * 
     * @type {number}
     * @memberof VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGet
     */
    readonly offset?: number
}

/**
 * VariableApi - object-oriented interface
 * @export
 * @class VariableApi
 * @extends {BaseAPI}
 */
export class VariableApi extends BaseAPI {
    /**
     * Get information for variable findings.
     * @summary Get Findings Of A Variable.
     * @param {VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public getFindingsOfAVariableV1VariableVariableIdFindingsGet(requestParameters: VariableApiGetFindingsOfAVariableV1VariableVariableIdFindingsGetRequest, options?: AxiosRequestConfig) {
        return VariableApiFp(this.configuration).getFindingsOfAVariableV1VariableVariableIdFindingsGet(requestParameters.variableId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


