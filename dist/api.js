"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * System REST API
 * This is a REST API through which clients can interact with System - an **open**, **collaborative**, and **ever-growing knowledge base** of all the world\'s systems.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.SystemGraphApi = exports.SystemGraphApiFactory = exports.SystemGraphApiFp = exports.SystemGraphApiAxiosParamCreator = exports.StudyMetadataApi = exports.StudyMetadataApiFactory = exports.StudyMetadataApiFp = exports.StudyMetadataApiAxiosParamCreator = exports.StripeApi = exports.StripeApiFactory = exports.StripeApiFp = exports.StripeApiAxiosParamCreator = exports.SsoApi = exports.SsoApiFactory = exports.SsoApiFp = exports.SsoApiAxiosParamCreator = exports.SemanticSearchApi = exports.SemanticSearchApiFactory = exports.SemanticSearchApiFp = exports.SemanticSearchApiAxiosParamCreator = exports.RdbApi = exports.RdbApiFactory = exports.RdbApiFp = exports.RdbApiAxiosParamCreator = exports.QuerySuggestionsApi = exports.QuerySuggestionsApiFactory = exports.QuerySuggestionsApiFp = exports.QuerySuggestionsApiAxiosParamCreator = exports.PassthroughApi = exports.PassthroughApiFactory = exports.PassthroughApiFp = exports.PassthroughApiAxiosParamCreator = exports.ModeldbApi = exports.ModeldbApiFactory = exports.ModeldbApiFp = exports.ModeldbApiAxiosParamCreator = exports.MetricsApi = exports.MetricsApiFactory = exports.MetricsApiFp = exports.MetricsApiAxiosParamCreator = exports.FindingsApi = exports.FindingsApiFactory = exports.FindingsApiFp = exports.FindingsApiAxiosParamCreator = exports.FeedbackApi = exports.FeedbackApiFactory = exports.FeedbackApiFp = exports.FeedbackApiAxiosParamCreator = exports.EnterpriseApi = exports.EnterpriseApiFactory = exports.EnterpriseApiFp = exports.EnterpriseApiAxiosParamCreator = exports.ConceptsApi = exports.ConceptsApiFactory = exports.ConceptsApiFp = exports.ConceptsApiAxiosParamCreator = exports.AssociationsApi = exports.AssociationsApiFactory = exports.AssociationsApiFp = exports.AssociationsApiAxiosParamCreator = exports.AccessApi = exports.AccessApiFactory = exports.AccessApiFp = exports.AccessApiAxiosParamCreator = exports.StripeAccountStatus = exports.SignificanceLevel = exports.SemanticSearchType = exports.RetrievalStatus = exports.ResourceAction = exports.PollingStatus = exports.Ordering = exports.Metrics = exports.MessageType = exports.IntegrationType = exports.IntegrationState = exports.IdentityProvider = exports.GraphNodeType = exports.GraphLinkType = exports.FunctionStatus = exports.FeatureContributionMethod = exports.EvidenceCategory = exports.ConceptSortEnum = exports.ClusteringMethods = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ClusteringMethods;
(function (ClusteringMethods) {
    ClusteringMethods["Agglomerative"] = "agglomerative";
    ClusteringMethods["Dbscan"] = "dbscan";
    ClusteringMethods["Paraphrase"] = "paraphrase";
})(ClusteringMethods = exports.ClusteringMethods || (exports.ClusteringMethods = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ConceptSortEnum;
(function (ConceptSortEnum) {
    ConceptSortEnum["CreatedAt"] = "created_at";
    ConceptSortEnum["LastUpdatedAt"] = "last_updated_at";
    ConceptSortEnum["Name"] = "name";
})(ConceptSortEnum = exports.ConceptSortEnum || (exports.ConceptSortEnum = {}));
/**
 * Evidence category.
 * @export
 * @enum {string}
 */
var EvidenceCategory;
(function (EvidenceCategory) {
    EvidenceCategory["Statistical"] = "statistical";
    EvidenceCategory["Mechanistic"] = "mechanistic";
})(EvidenceCategory = exports.EvidenceCategory || (exports.EvidenceCategory = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var FeatureContributionMethod;
(function (FeatureContributionMethod) {
    FeatureContributionMethod["Gini"] = "gini";
    FeatureContributionMethod["Gain"] = "gain";
    FeatureContributionMethod["Shap"] = "shap";
    FeatureContributionMethod["Coefficient"] = "coefficient";
    FeatureContributionMethod["Lime"] = "lime";
    FeatureContributionMethod["Permutation"] = "permutation";
    FeatureContributionMethod["PearsonR"] = "pearson_r";
    FeatureContributionMethod["KendallTau"] = "kendall_tau";
    FeatureContributionMethod["CramerV"] = "cramer_v";
    FeatureContributionMethod["KruskalWallisHTest"] = "kruskal_wallis_h_test";
    FeatureContributionMethod["ControlVariable"] = "control_variable";
    FeatureContributionMethod["ProductMomentR"] = "product_moment_r";
    FeatureContributionMethod["FrequencyScore"] = "frequency_score";
    FeatureContributionMethod["OddsRatio"] = "odds_ratio";
    FeatureContributionMethod["RelativeRiskRatio"] = "relative_risk_ratio";
    FeatureContributionMethod["HazardRatio"] = "hazard_ratio";
    FeatureContributionMethod["MeanGainUnstandardized"] = "mean_gain_unstandardized";
    FeatureContributionMethod["MeanGainStandardized"] = "mean_gain_standardized";
    FeatureContributionMethod["MeanDifferenceUnstandardized"] = "mean_difference_unstandardized";
    FeatureContributionMethod["MeanDifferenceStandardized"] = "mean_difference_standardized";
    FeatureContributionMethod["ProportionDifference"] = "proportion_difference";
    FeatureContributionMethod["LogOddsRatio"] = "log_odds_ratio";
    FeatureContributionMethod["PearsonChiSquaredTest"] = "pearson_chi_squared_test";
    FeatureContributionMethod["Forecast"] = "forecast";
    FeatureContributionMethod["PercentChangeDifference"] = "percent_change_difference";
    FeatureContributionMethod["AdjustedOddsRatio"] = "adjusted_odds_ratio";
    FeatureContributionMethod["AdjustedHazardRatio"] = "adjusted_hazard_ratio";
    FeatureContributionMethod["IncidentRateRatio"] = "incident_rate_ratio";
    FeatureContributionMethod["RiskDifference"] = "risk_difference";
    FeatureContributionMethod["InformationFlow"] = "information_flow";
    FeatureContributionMethod["StandardizedCoefficient"] = "standardized_coefficient";
    FeatureContributionMethod["CohensD"] = "cohens_d";
    FeatureContributionMethod["HedgesG"] = "hedges_g";
    FeatureContributionMethod["GlassSDelta"] = "glass_s_delta";
    FeatureContributionMethod["RootMeanSquareDifferencePsi"] = "root_mean_square_difference_psi";
    FeatureContributionMethod["MahalanobisDistance"] = "mahalanobis_distance";
    FeatureContributionMethod["CohensW"] = "cohens_w";
    FeatureContributionMethod["CohensH"] = "cohens_h";
    FeatureContributionMethod["CliffsDelta"] = "cliffs_delta";
    FeatureContributionMethod["RankBiserialCorrelation"] = "rank_biserial_correlation";
    FeatureContributionMethod["SpearmanCorrelation"] = "spearman_correlation";
    FeatureContributionMethod["Elasticity"] = "elasticity";
    FeatureContributionMethod["PrevalenceRatio"] = "prevalence_ratio";
    FeatureContributionMethod["Invalid"] = "invalid";
})(FeatureContributionMethod = exports.FeatureContributionMethod || (exports.FeatureContributionMethod = {}));
/**
 * Status for polling functions.
 * @export
 * @enum {string}
 */
var FunctionStatus;
(function (FunctionStatus) {
    FunctionStatus["Pending"] = "pending";
    FunctionStatus["Running"] = "running";
    FunctionStatus["Finished"] = "finished";
    FunctionStatus["Error"] = "error";
})(FunctionStatus = exports.FunctionStatus || (exports.FunctionStatus = {}));
/**
 * Graph Link Type enum.
 * @export
 * @enum {string}
 */
var GraphLinkType;
(function (GraphLinkType) {
    GraphLinkType["DatasetRelationship"] = "dataset_relationship";
    GraphLinkType["ConceptRelationship"] = "concept_relationship";
    GraphLinkType["VariableRelationship"] = "variable_relationship";
    GraphLinkType["FeatureRelationship"] = "feature_relationship";
    GraphLinkType["FeatureVariable"] = "feature_variable";
    GraphLinkType["Measures"] = "measures";
})(GraphLinkType = exports.GraphLinkType || (exports.GraphLinkType = {}));
/**
 * Graph Node Type enum.
 * @export
 * @enum {string}
 */
var GraphNodeType;
(function (GraphNodeType) {
    GraphNodeType["Dataset"] = "dataset";
    GraphNodeType["Concept"] = "concept";
    GraphNodeType["Variable"] = "variable";
    GraphNodeType["Feature"] = "feature";
})(GraphNodeType = exports.GraphNodeType || (exports.GraphNodeType = {}));
/**
 * SSO Identity Providers preconfigured in AWS Cognito user pool.
 * @export
 * @enum {string}
 */
var IdentityProvider;
(function (IdentityProvider) {
    IdentityProvider["Google"] = "Google";
    IdentityProvider["KeycloakGoogleDev"] = "keycloak-google-dev";
})(IdentityProvider = exports.IdentityProvider || (exports.IdentityProvider = {}));
/**
 * Integration service state.
 * @export
 * @enum {string}
 */
var IntegrationState;
(function (IntegrationState) {
    IntegrationState["Initial"] = "INITIAL";
    IntegrationState["Active"] = "ACTIVE";
    IntegrationState["Inactive"] = "INACTIVE";
})(IntegrationState = exports.IntegrationState || (exports.IntegrationState = {}));
/**
 * Integration retrieval types.
 * @export
 * @enum {string}
 */
var IntegrationType;
(function (IntegrationType) {
    IntegrationType["Redshift"] = "REDSHIFT";
    IntegrationType["Snowflake"] = "SNOWFLAKE";
    IntegrationType["Bigquery"] = "BIGQUERY";
    IntegrationType["Looker"] = "LOOKER";
    IntegrationType["Mode"] = "MODE";
})(IntegrationType = exports.IntegrationType || (exports.IntegrationType = {}));
/**
 * Message type.
 * @export
 * @enum {string}
 */
var MessageType;
(function (MessageType) {
    MessageType["Error"] = "ERROR";
    MessageType["DatasetCreated"] = "DATASET_CREATED";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * Metrics name enum.
 * @export
 * @enum {string}
 */
var Metrics;
(function (Metrics) {
    Metrics["SearchCreate"] = "semantic_search.create";
    Metrics["SearchClusterRead"] = "semantic_search_cluster.read";
})(Metrics = exports.Metrics || (exports.Metrics = {}));
/**
 * Ordering direction enum.
 * @export
 * @enum {string}
 */
var Ordering;
(function (Ordering) {
    Ordering["Asc"] = "asc";
    Ordering["Desc"] = "desc";
})(Ordering = exports.Ordering || (exports.Ordering = {}));
/**
 * Polling status enum.
 * @export
 * @enum {string}
 */
var PollingStatus;
(function (PollingStatus) {
    PollingStatus["NotExists"] = "not_exists";
    PollingStatus["Submitted"] = "submitted";
    PollingStatus["Running"] = "running";
    PollingStatus["Success"] = "success";
    PollingStatus["Failed"] = "failed";
    PollingStatus["FailedNoCitations"] = "failed_no_citations";
})(PollingStatus = exports.PollingStatus || (exports.PollingStatus = {}));
/**
 * API resource action enum.
 * @export
 * @enum {string}
 */
var ResourceAction;
(function (ResourceAction) {
    ResourceAction["Create"] = "create";
    ResourceAction["View"] = "view";
    ResourceAction["Edit"] = "edit";
    ResourceAction["Delete"] = "delete";
})(ResourceAction = exports.ResourceAction || (exports.ResourceAction = {}));
/**
 * Table retrieval status.
 * @export
 * @enum {string}
 */
var RetrievalStatus;
(function (RetrievalStatus) {
    RetrievalStatus["Pending"] = "pending";
    RetrievalStatus["Success"] = "success";
    RetrievalStatus["Failure"] = "failure";
})(RetrievalStatus = exports.RetrievalStatus || (exports.RetrievalStatus = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var SemanticSearchType;
(function (SemanticSearchType) {
    SemanticSearchType["RiskFactorOf"] = "risk_factor_of";
    SemanticSearchType["Outcome"] = "outcome";
    SemanticSearchType["Relationship"] = "relationship";
    SemanticSearchType["Relationship2d"] = "relationship_2d";
    SemanticSearchType["SingleVariable2d"] = "single_variable_2d";
})(SemanticSearchType = exports.SemanticSearchType || (exports.SemanticSearchType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var SignificanceLevel;
(function (SignificanceLevel) {
    SignificanceLevel["NinetyFive"] = "ninety_five";
    SignificanceLevel["NinetyNine"] = "ninety_nine";
    SignificanceLevel["NinetyNinePointNine"] = "ninety_nine_point_nine";
    SignificanceLevel["Invalid"] = "invalid";
})(SignificanceLevel = exports.SignificanceLevel || (exports.SignificanceLevel = {}));
/**
 * Stripe account status enum.
 * @export
 * @enum {string}
 */
var StripeAccountStatus;
(function (StripeAccountStatus) {
    StripeAccountStatus["Trial"] = "trial";
    StripeAccountStatus["Subscribed"] = "subscribed";
    StripeAccountStatus["Expired"] = "expired";
    StripeAccountStatus["GroupSubscribed"] = "group_subscribed";
    StripeAccountStatus["Unsubscribed"] = "unsubscribed";
})(StripeAccountStatus = exports.StripeAccountStatus || (exports.StripeAccountStatus = {}));
/**
 * AccessApi - axios parameter creator
 * @export
 */
exports.AccessApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDataAccessV1AccessDataPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/access/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMapsAccessV1AccessMapsPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/access/maps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AccessApi - functional programming interface
 * @export
 */
exports.AccessApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AccessApiAxiosParamCreator(configuration);
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDataAccessV1AccessDataPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestDataAccessV1AccessDataPost(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMapsAccessV1AccessMapsPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestMapsAccessV1AccessMapsPost(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * AccessApi - factory interface
 * @export
 */
exports.AccessApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AccessApiFp(configuration);
    return {
        /**
         * Register user\'s interest in access to Data Beta.
         * @summary Request Data Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDataAccessV1AccessDataPost(options) {
            return localVarFp.requestDataAccessV1AccessDataPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Register user\'s interest in access to Maps Beta.
         * @summary Request Maps Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestMapsAccessV1AccessMapsPost(options) {
            return localVarFp.requestMapsAccessV1AccessMapsPost(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
class AccessApi extends base_1.BaseAPI {
    /**
     * Register user\'s interest in access to Data Beta.
     * @summary Request Data Access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    requestDataAccessV1AccessDataPost(options) {
        return exports.AccessApiFp(this.configuration).requestDataAccessV1AccessDataPost(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register user\'s interest in access to Maps Beta.
     * @summary Request Maps Access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    requestMapsAccessV1AccessMapsPost(options) {
        return exports.AccessApiFp(this.configuration).requestMapsAccessV1AccessMapsPost(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccessApi = AccessApi;
/**
 * AssociationsApi - axios parameter creator
 * @export
 */
exports.AssociationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost: (associationId, resourceFlagIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'associationId' is not null or undefined
            common_1.assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost', 'associationId', associationId);
            // verify required parameter 'resourceFlagIn' is not null or undefined
            common_1.assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost', 'resourceFlagIn', resourceFlagIn);
            const localVarPath = `/v1/associations/{association_id}/flags`
                .replace(`{${"association_id"}}`, encodeURIComponent(String(associationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(resourceFlagIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost_1: (associationId, resourceFlagIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'associationId' is not null or undefined
            common_1.assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost_1', 'associationId', associationId);
            // verify required parameter 'resourceFlagIn' is not null or undefined
            common_1.assertParamExists('flagAssociationV1AssociationsAssociationIdFlagsPost_1', 'resourceFlagIn', resourceFlagIn);
            const localVarPath = `/v1/associations/{association_id}/flags`
                .replace(`{${"association_id"}}`, encodeURIComponent(String(associationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(resourceFlagIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFreeMetadataV1AssociationsFreeMetadataGet: (ids, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/associations/free_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AssociationsApi - functional programming interface
 * @export
 */
exports.AssociationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AssociationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFreeMetadataV1AssociationsFreeMetadataGet(ids, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFreeMetadataV1AssociationsFreeMetadataGet(ids, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * AssociationsApi - factory interface
 * @export
 */
exports.AssociationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AssociationsApiFp(configuration);
    return {
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options) {
            return localVarFp.flagAssociationV1AssociationsAssociationIdFlagsPost(associationId, resourceFlagIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get strength of this association.
         * @summary Flag Association
         * @param {string} associationId
         * @param {ResourceFlagIn} resourceFlagIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options) {
            return localVarFp.flagAssociationV1AssociationsAssociationIdFlagsPost_1(associationId, resourceFlagIn, options).then((request) => request(axios, basePath));
        },
        /**
         * List Associations.
         * @summary List Free Metadata
         * @param {Array<string>} [ids] List of association IDs to fetch free metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFreeMetadataV1AssociationsFreeMetadataGet(ids, options) {
            return localVarFp.listFreeMetadataV1AssociationsFreeMetadataGet(ids, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AssociationsApi - object-oriented interface
 * @export
 * @class AssociationsApi
 * @extends {BaseAPI}
 */
class AssociationsApi extends base_1.BaseAPI {
    /**
     * Get strength of this association.
     * @summary Flag Association
     * @param {AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    flagAssociationV1AssociationsAssociationIdFlagsPost(requestParameters, options) {
        return exports.AssociationsApiFp(this.configuration).flagAssociationV1AssociationsAssociationIdFlagsPost(requestParameters.associationId, requestParameters.resourceFlagIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get strength of this association.
     * @summary Flag Association
     * @param {AssociationsApiFlagAssociationV1AssociationsAssociationIdFlagsPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    flagAssociationV1AssociationsAssociationIdFlagsPost_1(requestParameters, options) {
        return exports.AssociationsApiFp(this.configuration).flagAssociationV1AssociationsAssociationIdFlagsPost_1(requestParameters.associationId, requestParameters.resourceFlagIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Associations.
     * @summary List Free Metadata
     * @param {AssociationsApiListFreeMetadataV1AssociationsFreeMetadataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    listFreeMetadataV1AssociationsFreeMetadataGet(requestParameters = {}, options) {
        return exports.AssociationsApiFp(this.configuration).listFreeMetadataV1AssociationsFreeMetadataGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AssociationsApi = AssociationsApi;
/**
 * ConceptsApi - axios parameter creator
 * @export
 */
exports.ConceptsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet: (conceptId, topPercentileLimit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conceptId' is not null or undefined
            common_1.assertParamExists('getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet', 'conceptId', conceptId);
            const localVarPath = `/v1/concepts/{concept_id}/relationships`
                .replace(`{${"concept_id"}}`, encodeURIComponent(String(conceptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (topPercentileLimit !== undefined) {
                localVarQueryParameter['top_percentile_limit'] = topPercentileLimit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptV1ConceptsConceptIdGet: (conceptId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conceptId' is not null or undefined
            common_1.assertParamExists('getConceptV1ConceptsConceptIdGet', 'conceptId', conceptId);
            const localVarPath = `/v1/concepts/{concept_id}`
                .replace(`{${"concept_id"}}`, encodeURIComponent(String(conceptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId]
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConceptsV1ConceptsGet: (teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            if (minRelationshipStrength !== undefined) {
                localVarQueryParameter['min_relationship_strength'] = minRelationshipStrength;
            }
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (includeHidden !== undefined) {
                localVarQueryParameter['include_hidden'] = includeHidden;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }
            if (idsOnly !== undefined) {
                localVarQueryParameter['ids_only'] = idsOnly;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (inConceptGraph !== undefined) {
                localVarQueryParameter['in_concept_graph'] = inConceptGraph;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchConceptsV1ConceptsSemanticGet: (query, alpha, autocut, customCutoffScore, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('semanticSearchConceptsV1ConceptsSemanticGet', 'query', query);
            const localVarPath = `/v1/concepts/semantic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }
            if (alpha !== undefined) {
                localVarQueryParameter['alpha'] = alpha;
            }
            if (autocut !== undefined) {
                localVarQueryParameter['autocut'] = autocut;
            }
            if (customCutoffScore !== undefined) {
                localVarQueryParameter['custom_cutoff_score'] = customCutoffScore;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ConceptsApi - functional programming interface
 * @export
 */
exports.ConceptsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ConceptsApiAxiosParamCreator(configuration);
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptV1ConceptsConceptIdGet(conceptId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConceptV1ConceptsConceptIdGet(conceptId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId]
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ConceptsApi - factory interface
 * @export
 */
exports.ConceptsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ConceptsApiFp(configuration);
    return {
        /**
         * Fetch concept relationships.
         * @summary Get Concept Relationships
         * @param {string} conceptId
         * @param {boolean} [topPercentileLimit] Flag for limiting to top percentile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options) {
            return localVarFp.getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(conceptId, topPercentileLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Concept.
         * @summary Get Concept
         * @param {string} conceptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptV1ConceptsConceptIdGet(conceptId, options) {
            return localVarFp.getConceptV1ConceptsConceptIdGet(conceptId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Concepts.
         * @summary List Concepts
         * @param {string} [teamId]
         * @param {number} [minRelationshipStrength] Min strength
         * @param {string} [query] Search query.
         * @param {boolean} [includeHidden] Include hidden objects in results.
         * @param {Array<string>} [id] Filter results by id.
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [total] Include total count in response. Only use if you need it as a separate database call is required.
         * @param {boolean} [idsOnly] Only return ids. Will return an empty list for &#x60;items&#x60;.Will speed up the call to this endpoint if possible.
         * @param {ConceptSortEnum} [orderBy] Order by this field.
         * @param {Ordering} [ordering] Order ascending or descending.
         * @param {string} [sortBy] Multi sorting parameter consisting of csv list of form \&#39;field1|asc,field2|desc,field3\&#39;. If sorting direction is not specified by &#x60;|asc&#x60; or &#x60;|desc&#x60; then descending is assumed.
         * @param {boolean} [inConceptGraph] Is Concept in the Concept Graph?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options) {
            return localVarFp.listConceptsV1ConceptsGet(teamId, minRelationshipStrength, query, includeHidden, id, page, pageSize, total, idsOnly, orderBy, ordering, sortBy, inConceptGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * List Concepts.
         * @summary Semantic Search Concepts
         * @param {string} query Query for the search.
         * @param {number} [alpha] Alpha for the search.
         * @param {number} [autocut] Autocut for the search.
         * @param {number} [customCutoffScore] Custom cutoff score.
         * @param {number} [limit] Limit for the search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options) {
            return localVarFp.semanticSearchConceptsV1ConceptsSemanticGet(query, alpha, autocut, customCutoffScore, limit, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ConceptsApi - object-oriented interface
 * @export
 * @class ConceptsApi
 * @extends {BaseAPI}
 */
class ConceptsApi extends base_1.BaseAPI {
    /**
     * Fetch concept relationships.
     * @summary Get Concept Relationships
     * @param {ConceptsApiGetConceptRelationshipsV1ConceptsConceptIdRelationshipsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(requestParameters, options) {
        return exports.ConceptsApiFp(this.configuration).getConceptRelationshipsV1ConceptsConceptIdRelationshipsGet(requestParameters.conceptId, requestParameters.topPercentileLimit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Concept.
     * @summary Get Concept
     * @param {ConceptsApiGetConceptV1ConceptsConceptIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    getConceptV1ConceptsConceptIdGet(requestParameters, options) {
        return exports.ConceptsApiFp(this.configuration).getConceptV1ConceptsConceptIdGet(requestParameters.conceptId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Concepts.
     * @summary List Concepts
     * @param {ConceptsApiListConceptsV1ConceptsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    listConceptsV1ConceptsGet(requestParameters = {}, options) {
        return exports.ConceptsApiFp(this.configuration).listConceptsV1ConceptsGet(requestParameters.teamId, requestParameters.minRelationshipStrength, requestParameters.query, requestParameters.includeHidden, requestParameters.id, requestParameters.page, requestParameters.pageSize, requestParameters.total, requestParameters.idsOnly, requestParameters.orderBy, requestParameters.ordering, requestParameters.sortBy, requestParameters.inConceptGraph, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Concepts.
     * @summary Semantic Search Concepts
     * @param {ConceptsApiSemanticSearchConceptsV1ConceptsSemanticGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptsApi
     */
    semanticSearchConceptsV1ConceptsSemanticGet(requestParameters, options) {
        return exports.ConceptsApiFp(this.configuration).semanticSearchConceptsV1ConceptsSemanticGet(requestParameters.query, requestParameters.alpha, requestParameters.autocut, requestParameters.customCutoffScore, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ConceptsApi = ConceptsApi;
/**
 * EnterpriseApi - axios parameter creator
 * @export
 */
exports.EnterpriseApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationV1EnterpriseIntegrationsPost: (integrationIn, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'integrationIn' is not null or undefined
            common_1.assertParamExists('createIntegrationV1EnterpriseIntegrationsPost', 'integrationIn', integrationIn);
            const localVarPath = `/v1/enterprise/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(integrationIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageV1EnterpriseMessagesPost: (messageIn, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'messageIn' is not null or undefined
            common_1.assertParamExists('createMessageV1EnterpriseMessagesPost', 'messageIn', messageIn);
            const localVarPath = `/v1/enterprise/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(messageIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterpriseV1EnterpriseGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/enterprise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationV1EnterpriseIntegrationsIntegrationIdGet: (integrationId, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'integrationId' is not null or undefined
            common_1.assertParamExists('getIntegrationV1EnterpriseIntegrationsIntegrationIdGet', 'integrationId', integrationId);
            const localVarPath = `/v1/enterprise/integrations/{integration_id}`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsV1EnterpriseIntegrationsGet: (teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/enterprise/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageV1EnterpriseMessagesMessageIdGet: (messageId, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'messageId' is not null or undefined
            common_1.assertParamExists('getMessageV1EnterpriseMessagesMessageIdGet', 'messageId', messageId);
            const localVarPath = `/v1/enterprise/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterpriseV1EnterprisePatch: (enterpriseIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'enterpriseIn' is not null or undefined
            common_1.assertParamExists('updateEnterpriseV1EnterprisePatch', 'enterpriseIn', enterpriseIn);
            const localVarPath = `/v1/enterprise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(enterpriseIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch: (integrationId, integrationIn, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'integrationId' is not null or undefined
            common_1.assertParamExists('updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch', 'integrationId', integrationId);
            // verify required parameter 'integrationIn' is not null or undefined
            common_1.assertParamExists('updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch', 'integrationIn', integrationIn);
            const localVarPath = `/v1/enterprise/integrations/{integration_id}`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(integrationIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageV1EnterpriseMessagesMessageIdPatch: (messageId, messageIn, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'messageId' is not null or undefined
            common_1.assertParamExists('updateMessageV1EnterpriseMessagesMessageIdPatch', 'messageId', messageId);
            // verify required parameter 'messageIn' is not null or undefined
            common_1.assertParamExists('updateMessageV1EnterpriseMessagesMessageIdPatch', 'messageIn', messageIn);
            const localVarPath = `/v1/enterprise/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(messageIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * EnterpriseApi - functional programming interface
 * @export
 */
exports.EnterpriseApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.EnterpriseApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageV1EnterpriseMessagesPost(messageIn, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMessageV1EnterpriseMessagesPost(messageIn, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterpriseV1EnterpriseGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEnterpriseV1EnterpriseGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsV1EnterpriseIntegrationsGet(teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIntegrationsV1EnterpriseIntegrationsGet(teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterpriseV1EnterprisePatch(enterpriseIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEnterpriseV1EnterprisePatch(enterpriseIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * EnterpriseApi - factory interface
 * @export
 */
exports.EnterpriseApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.EnterpriseApiFp(configuration);
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options) {
            return localVarFp.createIntegrationV1EnterpriseIntegrationsPost(integrationIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new message.
         * @summary Create Message
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageV1EnterpriseMessagesPost(messageIn, teamId, options) {
            return localVarFp.createMessageV1EnterpriseMessagesPost(messageIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Enterprise.
         * @summary Get Enterprise
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterpriseV1EnterpriseGet(options) {
            return localVarFp.getEnterpriseV1EnterpriseGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Integration.
         * @summary Get Integration
         * @param {string} integrationId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options) {
            return localVarFp.getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(integrationId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get team integrations.
         * @summary Get Integrations
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationsV1EnterpriseIntegrationsGet(teamId, options) {
            return localVarFp.getIntegrationsV1EnterpriseIntegrationsGet(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Message.
         * @summary Get Message
         * @param {string} messageId
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options) {
            return localVarFp.getMessageV1EnterpriseMessagesMessageIdGet(messageId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Enterprise.
         * @summary Update Enterprise
         * @param {EnterpriseIn} enterpriseIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterpriseV1EnterprisePatch(enterpriseIn, options) {
            return localVarFp.updateEnterpriseV1EnterprisePatch(enterpriseIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Integration.
         * @summary Update Integration
         * @param {string} integrationId
         * @param {IntegrationIn} integrationIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options) {
            return localVarFp.updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(integrationId, integrationIn, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Message.
         * @summary Update Message
         * @param {string} messageId
         * @param {MessageIn} messageIn
         * @param {string} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options) {
            return localVarFp.updateMessageV1EnterpriseMessagesMessageIdPatch(messageId, messageIn, teamId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EnterpriseApi - object-oriented interface
 * @export
 * @class EnterpriseApi
 * @extends {BaseAPI}
 */
class EnterpriseApi extends base_1.BaseAPI {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {EnterpriseApiCreateIntegrationV1EnterpriseIntegrationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    createIntegrationV1EnterpriseIntegrationsPost(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).createIntegrationV1EnterpriseIntegrationsPost(requestParameters.integrationIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new message.
     * @summary Create Message
     * @param {EnterpriseApiCreateMessageV1EnterpriseMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    createMessageV1EnterpriseMessagesPost(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).createMessageV1EnterpriseMessagesPost(requestParameters.messageIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the Enterprise.
     * @summary Get Enterprise
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    getEnterpriseV1EnterpriseGet(options) {
        return exports.EnterpriseApiFp(this.configuration).getEnterpriseV1EnterpriseGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an Integration.
     * @summary Get Integration
     * @param {EnterpriseApiGetIntegrationV1EnterpriseIntegrationsIntegrationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).getIntegrationV1EnterpriseIntegrationsIntegrationIdGet(requestParameters.integrationId, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get team integrations.
     * @summary Get Integrations
     * @param {EnterpriseApiGetIntegrationsV1EnterpriseIntegrationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    getIntegrationsV1EnterpriseIntegrationsGet(requestParameters = {}, options) {
        return exports.EnterpriseApiFp(this.configuration).getIntegrationsV1EnterpriseIntegrationsGet(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Message.
     * @summary Get Message
     * @param {EnterpriseApiGetMessageV1EnterpriseMessagesMessageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    getMessageV1EnterpriseMessagesMessageIdGet(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).getMessageV1EnterpriseMessagesMessageIdGet(requestParameters.messageId, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Enterprise.
     * @summary Update Enterprise
     * @param {EnterpriseApiUpdateEnterpriseV1EnterprisePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    updateEnterpriseV1EnterprisePatch(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).updateEnterpriseV1EnterprisePatch(requestParameters.enterpriseIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update Integration.
     * @summary Update Integration
     * @param {EnterpriseApiUpdateIntegrationV1EnterpriseIntegrationsIntegrationIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).updateIntegrationV1EnterpriseIntegrationsIntegrationIdPatch(requestParameters.integrationId, requestParameters.integrationIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Message.
     * @summary Update Message
     * @param {EnterpriseApiUpdateMessageV1EnterpriseMessagesMessageIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    updateMessageV1EnterpriseMessagesMessageIdPatch(requestParameters, options) {
        return exports.EnterpriseApiFp(this.configuration).updateMessageV1EnterpriseMessagesMessageIdPatch(requestParameters.messageId, requestParameters.messageIn, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EnterpriseApi = EnterpriseApi;
/**
 * FeedbackApi - axios parameter creator
 * @export
 */
exports.FeedbackApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSynthesisFeedbackV1FeedbackPost: (synthesisFeedbackIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'synthesisFeedbackIn' is not null or undefined
            common_1.assertParamExists('postSynthesisFeedbackV1FeedbackPost', 'synthesisFeedbackIn', synthesisFeedbackIn);
            const localVarPath = `/v1/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(synthesisFeedbackIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FeedbackApi - functional programming interface
 * @export
 */
exports.FeedbackApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FeedbackApiAxiosParamCreator(configuration);
    return {
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * FeedbackApi - factory interface
 * @export
 */
exports.FeedbackApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FeedbackApiFp(configuration);
    return {
        /**
         * Post user feedback on AI-generated relationship synthesis to s3.
         * @summary Post Synthesis Feedback
         * @param {SynthesisFeedbackIn} synthesisFeedbackIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options) {
            return localVarFp.postSynthesisFeedbackV1FeedbackPost(synthesisFeedbackIn, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
class FeedbackApi extends base_1.BaseAPI {
    /**
     * Post user feedback on AI-generated relationship synthesis to s3.
     * @summary Post Synthesis Feedback
     * @param {FeedbackApiPostSynthesisFeedbackV1FeedbackPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    postSynthesisFeedbackV1FeedbackPost(requestParameters, options) {
        return exports.FeedbackApiFp(this.configuration).postSynthesisFeedbackV1FeedbackPost(requestParameters.synthesisFeedbackIn, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FeedbackApi = FeedbackApi;
/**
 * FindingsApi - axios parameter creator
 * @export
 */
exports.FindingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost: (studyFindingsIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'studyFindingsIn' is not null or undefined
            common_1.assertParamExists('getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost', 'studyFindingsIn', studyFindingsIn);
            const localVarPath = `/v1/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(studyFindingsIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FindingsApi - functional programming interface
 * @export
 */
exports.FindingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FindingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * FindingsApi - factory interface
 * @export
 */
exports.FindingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FindingsApiFp(configuration);
    return {
        /**
         * Get study findings via association ids or dois.
         * @summary Get Study Findings From Association Ids Or Dois
         * @param {StudyFindingsIn} studyFindingsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options) {
            return localVarFp.getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(studyFindingsIn, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FindingsApi - object-oriented interface
 * @export
 * @class FindingsApi
 * @extends {BaseAPI}
 */
class FindingsApi extends base_1.BaseAPI {
    /**
     * Get study findings via association ids or dois.
     * @summary Get Study Findings From Association Ids Or Dois
     * @param {FindingsApiGetStudyFindingsFromAssociationIdsOrDOIsV1FindingsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FindingsApi
     */
    getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(requestParameters, options) {
        return exports.FindingsApiFp(this.configuration).getStudyFindingsFromAssociationIdsOrDOIsV1FindingsPost(requestParameters.studyFindingsIn, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FindingsApi = FindingsApi;
/**
 * MetricsApi - axios parameter creator
 * @export
 */
exports.MetricsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetricsV1MetricsGraphGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/metrics/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * MetricsApi - functional programming interface
 * @export
 */
exports.MetricsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.MetricsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetricsV1MetricsGraphGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGraphMetricsV1MetricsGraphGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * MetricsApi - factory interface
 * @export
 */
exports.MetricsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.MetricsApiFp(configuration);
    return {
        /**
         * Get metrics on the graph.
         * @summary Get Graph Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetricsV1MetricsGraphGet(options) {
            return localVarFp.getGraphMetricsV1MetricsGraphGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
class MetricsApi extends base_1.BaseAPI {
    /**
     * Get metrics on the graph.
     * @summary Get Graph Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    getGraphMetricsV1MetricsGraphGet(options) {
        return exports.MetricsApiFp(this.configuration).getGraphMetricsV1MetricsGraphGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MetricsApi = MetricsApi;
/**
 * ModeldbApi - axios parameter creator
 * @export
 */
exports.ModeldbApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet: (algorithmId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'algorithmId' is not null or undefined
            common_1.assertParamExists('getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet', 'algorithmId', algorithmId);
            const localVarPath = `/v1/modeldb/algorithms/{algorithm_id}`
                .replace(`{${"algorithm_id"}}`, encodeURIComponent(String(algorithmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithmsV1ModeldbAlgorithmsGet: (algorithmClass, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/modeldb/algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (algorithmClass !== undefined) {
                localVarQueryParameter['algorithm_class'] = algorithmClass;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ModeldbApi - functional programming interface
 * @export
 */
exports.ModeldbApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ModeldbApiAxiosParamCreator(configuration);
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ModeldbApi - factory interface
 * @export
 */
exports.ModeldbApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ModeldbApiFp(configuration);
    return {
        /**
         * Get algorithms by id.
         * @summary Get Algorithm
         * @param {string} algorithmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options) {
            return localVarFp.getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(algorithmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List available algorithms in ModelDB. Search with algorithm class if passed.
         * @summary List Algorithms
         * @param {string} [algorithmClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options) {
            return localVarFp.listAlgorithmsV1ModeldbAlgorithmsGet(algorithmClass, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ModeldbApi - object-oriented interface
 * @export
 * @class ModeldbApi
 * @extends {BaseAPI}
 */
class ModeldbApi extends base_1.BaseAPI {
    /**
     * Get algorithms by id.
     * @summary Get Algorithm
     * @param {ModeldbApiGetAlgorithmV1ModeldbAlgorithmsAlgorithmIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModeldbApi
     */
    getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(requestParameters, options) {
        return exports.ModeldbApiFp(this.configuration).getAlgorithmV1ModeldbAlgorithmsAlgorithmIdGet(requestParameters.algorithmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List available algorithms in ModelDB. Search with algorithm class if passed.
     * @summary List Algorithms
     * @param {ModeldbApiListAlgorithmsV1ModeldbAlgorithmsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModeldbApi
     */
    listAlgorithmsV1ModeldbAlgorithmsGet(requestParameters = {}, options) {
        return exports.ModeldbApiFp(this.configuration).listAlgorithmsV1ModeldbAlgorithmsGet(requestParameters.algorithmClass, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ModeldbApi = ModeldbApi;
/**
 * PassthroughApi - axios parameter creator
 * @export
 */
exports.PassthroughApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossrefV1CrossrefRestOfPathGet: (restOfPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'restOfPath' is not null or undefined
            common_1.assertParamExists('getCrossrefV1CrossrefRestOfPathGet', 'restOfPath', restOfPath);
            const localVarPath = `/v1/crossref/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFtrEntitlementsV1GetftrEntitlementsPost: (getFTREntitlementsIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'getFTREntitlementsIn' is not null or undefined
            common_1.assertParamExists('getFtrEntitlementsV1GetftrEntitlementsPost', 'getFTREntitlementsIn', getFTREntitlementsIn);
            const localVarPath = `/v1/getftr/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(getFTREntitlementsIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrcidV1OrcidRestOfPathGet: (restOfPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'restOfPath' is not null or undefined
            common_1.assertParamExists('getOrcidV1OrcidRestOfPathGet', 'restOfPath', restOfPath);
            const localVarPath = `/v1/orcid/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphV1SemanticGraphRestOfPathGet: (restOfPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'restOfPath' is not null or undefined
            common_1.assertParamExists('getSemanticGraphV1SemanticGraphRestOfPathGet', 'restOfPath', restOfPath);
            const localVarPath = `/v1/semantic_graph/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmlsConceptsV1UmlsRestOfPathGet: (restOfPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'restOfPath' is not null or undefined
            common_1.assertParamExists('getUmlsConceptsV1UmlsRestOfPathGet', 'restOfPath', restOfPath);
            const localVarPath = `/v1/umls/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableConceptsV1VariableConceptsRestOfPathGet: (restOfPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'restOfPath' is not null or undefined
            common_1.assertParamExists('getVariableConceptsV1VariableConceptsRestOfPathGet', 'restOfPath', restOfPath);
            const localVarPath = `/v1/variable_concepts/{rest_of_path}`
                .replace(`{${"rest_of_path"}}`, encodeURIComponent(String(restOfPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphqlV1GraphqlPost: (graphQLQuery, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'graphQLQuery' is not null or undefined
            common_1.assertParamExists('postGraphqlV1GraphqlPost', 'graphQLQuery', graphQLQuery);
            const localVarPath = `/v1/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(graphQLQuery, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * PassthroughApi - functional programming interface
 * @export
 */
exports.PassthroughApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.PassthroughApiAxiosParamCreator(configuration);
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossrefV1CrossrefRestOfPathGet(restOfPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCrossrefV1CrossrefRestOfPathGet(restOfPath, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrcidV1OrcidRestOfPathGet(restOfPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrcidV1OrcidRestOfPathGet(restOfPath, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphqlV1GraphqlPost(graphQLQuery, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postGraphqlV1GraphqlPost(graphQLQuery, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * PassthroughApi - factory interface
 * @export
 */
exports.PassthroughApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.PassthroughApiFp(configuration);
    return {
        /**
         * Forward request to crossref.
         * @summary Get Crossref
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossrefV1CrossrefRestOfPathGet(restOfPath, options) {
            return localVarFp.getCrossrefV1CrossrefRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Post GetFTR entitlements endpoint.
         * @summary Get Ftr Entitlements
         * @param {GetFTREntitlementsIn} getFTREntitlementsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options) {
            return localVarFp.getFtrEntitlementsV1GetftrEntitlementsPost(getFTREntitlementsIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to ORCID.
         * @summary Get Orcid
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrcidV1OrcidRestOfPathGet(restOfPath, options) {
            return localVarFp.getOrcidV1OrcidRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Semantic Graph
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options) {
            return localVarFp.getSemanticGraphV1SemanticGraphRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to UMLS.
         * @summary Get Umls Concepts
         * @param {any} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options) {
            return localVarFp.getUmlsConceptsV1UmlsRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward request to SearchGraph.
         * @summary Get Variable Concepts
         * @param {string} restOfPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options) {
            return localVarFp.getVariableConceptsV1VariableConceptsRestOfPathGet(restOfPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Forward GraphQL request to SystemDB.
         * @summary Post Graphql
         * @param {GraphQLQuery} graphQLQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphqlV1GraphqlPost(graphQLQuery, options) {
            return localVarFp.postGraphqlV1GraphqlPost(graphQLQuery, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PassthroughApi - object-oriented interface
 * @export
 * @class PassthroughApi
 * @extends {BaseAPI}
 */
class PassthroughApi extends base_1.BaseAPI {
    /**
     * Forward request to crossref.
     * @summary Get Crossref
     * @param {PassthroughApiGetCrossrefV1CrossrefRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getCrossrefV1CrossrefRestOfPathGet(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getCrossrefV1CrossrefRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Post GetFTR entitlements endpoint.
     * @summary Get Ftr Entitlements
     * @param {PassthroughApiGetFtrEntitlementsV1GetftrEntitlementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getFtrEntitlementsV1GetftrEntitlementsPost(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getFtrEntitlementsV1GetftrEntitlementsPost(requestParameters.getFTREntitlementsIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forward request to ORCID.
     * @summary Get Orcid
     * @param {PassthroughApiGetOrcidV1OrcidRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getOrcidV1OrcidRestOfPathGet(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getOrcidV1OrcidRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forward request to SearchGraph.
     * @summary Get Semantic Graph
     * @param {PassthroughApiGetSemanticGraphV1SemanticGraphRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getSemanticGraphV1SemanticGraphRestOfPathGet(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getSemanticGraphV1SemanticGraphRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forward request to UMLS.
     * @summary Get Umls Concepts
     * @param {PassthroughApiGetUmlsConceptsV1UmlsRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getUmlsConceptsV1UmlsRestOfPathGet(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getUmlsConceptsV1UmlsRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forward request to SearchGraph.
     * @summary Get Variable Concepts
     * @param {PassthroughApiGetVariableConceptsV1VariableConceptsRestOfPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    getVariableConceptsV1VariableConceptsRestOfPathGet(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).getVariableConceptsV1VariableConceptsRestOfPathGet(requestParameters.restOfPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forward GraphQL request to SystemDB.
     * @summary Post Graphql
     * @param {PassthroughApiPostGraphqlV1GraphqlPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassthroughApi
     */
    postGraphqlV1GraphqlPost(requestParameters, options) {
        return exports.PassthroughApiFp(this.configuration).postGraphqlV1GraphqlPost(requestParameters.graphQLQuery, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PassthroughApi = PassthroughApi;
/**
 * QuerySuggestionsApi - axios parameter creator
 * @export
 */
exports.QuerySuggestionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsV1QuerySuggestionsPost: (suggestedQueriesIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'suggestedQueriesIn' is not null or undefined
            common_1.assertParamExists('getQuerySuggestionsV1QuerySuggestionsPost', 'suggestedQueriesIn', suggestedQueriesIn);
            const localVarPath = `/v1/query_suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(suggestedQueriesIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * QuerySuggestionsApi - functional programming interface
 * @export
 */
exports.QuerySuggestionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QuerySuggestionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * QuerySuggestionsApi - factory interface
 * @export
 */
exports.QuerySuggestionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QuerySuggestionsApiFp(configuration);
    return {
        /**
         * Get query suggestions.
         * @summary Get Query Suggestions.
         * @param {SuggestedQueriesIn} suggestedQueriesIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options) {
            return localVarFp.getQuerySuggestionsV1QuerySuggestionsPost(suggestedQueriesIn, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QuerySuggestionsApi - object-oriented interface
 * @export
 * @class QuerySuggestionsApi
 * @extends {BaseAPI}
 */
class QuerySuggestionsApi extends base_1.BaseAPI {
    /**
     * Get query suggestions.
     * @summary Get Query Suggestions.
     * @param {QuerySuggestionsApiGetQuerySuggestionsV1QuerySuggestionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuerySuggestionsApi
     */
    getQuerySuggestionsV1QuerySuggestionsPost(requestParameters, options) {
        return exports.QuerySuggestionsApiFp(this.configuration).getQuerySuggestionsV1QuerySuggestionsPost(requestParameters.suggestedQueriesIn, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QuerySuggestionsApi = QuerySuggestionsApi;
/**
 * RdbApi - axios parameter creator
 * @export
 */
exports.RdbApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readEvidencesV1RdbEvidencesGet: (ids, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/rdb/evidences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudiesV1RdbStudiesGet: (ids, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/rdb/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RdbApi - functional programming interface
 * @export
 */
exports.RdbApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.RdbApiAxiosParamCreator(configuration);
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readEvidencesV1RdbEvidencesGet(ids, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readEvidencesV1RdbEvidencesGet(ids, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudiesV1RdbStudiesGet(ids, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readStudiesV1RdbStudiesGet(ids, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * RdbApi - factory interface
 * @export
 */
exports.RdbApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.RdbApiFp(configuration);
    return {
        /**
         * Read evidences.
         * @summary Read Evidences
         * @param {Array<string>} [ids] Evidence ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readEvidencesV1RdbEvidencesGet(ids, options) {
            return localVarFp.readEvidencesV1RdbEvidencesGet(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Read studies.
         * @summary Read Studies
         * @param {Array<string>} [ids] Study ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudiesV1RdbStudiesGet(ids, options) {
            return localVarFp.readStudiesV1RdbStudiesGet(ids, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RdbApi - object-oriented interface
 * @export
 * @class RdbApi
 * @extends {BaseAPI}
 */
class RdbApi extends base_1.BaseAPI {
    /**
     * Read evidences.
     * @summary Read Evidences
     * @param {RdbApiReadEvidencesV1RdbEvidencesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RdbApi
     */
    readEvidencesV1RdbEvidencesGet(requestParameters = {}, options) {
        return exports.RdbApiFp(this.configuration).readEvidencesV1RdbEvidencesGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Read studies.
     * @summary Read Studies
     * @param {RdbApiReadStudiesV1RdbStudiesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RdbApi
     */
    readStudiesV1RdbStudiesGet(requestParameters = {}, options) {
        return exports.RdbApiFp(this.configuration).readStudiesV1RdbStudiesGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RdbApi = RdbApi;
/**
 * SemanticSearchApi - axios parameter creator
 * @export
 */
exports.SemanticSearchApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost: (systemSearchIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'systemSearchIn' is not null or undefined
            common_1.assertParamExists('asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost', 'systemSearchIn', systemSearchIn);
            const localVarPath = `/v1/semantic-search/cluster_async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncSemanticSearchV1SemanticSearchClusterPost: (systemSearchIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'systemSearchIn' is not null or undefined
            common_1.assertParamExists('asyncSemanticSearchV1SemanticSearchClusterPost', 'systemSearchIn', systemSearchIn);
            const localVarPath = `/v1/semantic-search/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet: (runId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'runId' is not null or undefined
            common_1.assertParamExists('fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet', 'runId', runId);
            const localVarPath = `/v1/semantic-search/cluster_async/{run_id}`
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSynthesisV1SemanticSearchFetchGet: (cacheKey, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'cacheKey' is not null or undefined
            common_1.assertParamExists('fetchSynthesisV1SemanticSearchFetchGet', 'cacheKey', cacheKey);
            const localVarPath = `/v1/semantic-search/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (cacheKey !== undefined) {
                localVarQueryParameter['cache_key'] = cacheKey;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom]
         * @param {Metrics} [metric]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticSearchUsageV1SemanticSearchUsageGet: (dateFrom, metric, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/semantic-search/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom instanceof Date) ?
                    dateFrom.toISOString().substr(0, 10) :
                    dateFrom;
            }
            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchFindingsDataV1SemanticSearchDataPost: (systemSearchIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'systemSearchIn' is not null or undefined
            common_1.assertParamExists('getSystemSearchFindingsDataV1SemanticSearchDataPost', 'systemSearchIn', systemSearchIn);
            const localVarPath = `/v1/semantic-search/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(systemSearchIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey
         * @param {boolean} [forceRerun]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateSynthesisV1SemanticSearchRegeneratePost: (cacheKey, forceRerun, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'cacheKey' is not null or undefined
            common_1.assertParamExists('regenerateSynthesisV1SemanticSearchRegeneratePost', 'cacheKey', cacheKey);
            const localVarPath = `/v1/semantic-search/regenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (cacheKey !== undefined) {
                localVarQueryParameter['cache_key'] = cacheKey;
            }
            if (forceRerun !== undefined) {
                localVarQueryParameter['force_rerun'] = forceRerun;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SemanticSearchApi - functional programming interface
 * @export
 */
exports.SemanticSearchApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SemanticSearchApiAxiosParamCreator(configuration);
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom]
         * @param {Metrics} [metric]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey
         * @param {boolean} [forceRerun]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * SemanticSearchApi - factory interface
 * @export
 */
exports.SemanticSearchApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SemanticSearchApiFp(configuration);
    return {
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Cluster Relationships
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options) {
            return localVarFp.asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Async Semantic Search
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options) {
            return localVarFp.asyncSemanticSearchV1SemanticSearchClusterPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Fetch Cluster Response
         * @param {string} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options) {
            return localVarFp.fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search. Logs freemium usage on success
         * @summary Fetch Synthesis
         * @param {string} cacheKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options) {
            return localVarFp.fetchSynthesisV1SemanticSearchFetchGet(cacheKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
         * @summary Get Semantic Search Usage
         * @param {string} [dateFrom]
         * @param {Metrics} [metric]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options) {
            return localVarFp.getSemanticSearchUsageV1SemanticSearchUsageGet(dateFrom, metric, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search findings.  Values from semantic search.
         * @summary Get System Search Findings Data
         * @param {SystemSearchIn} systemSearchIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options) {
            return localVarFp.getSystemSearchFindingsDataV1SemanticSearchDataPost(systemSearchIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get semantic search.  Values from semantic search.
         * @summary Regenerate Synthesis
         * @param {string} cacheKey
         * @param {boolean} [forceRerun]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options) {
            return localVarFp.regenerateSynthesisV1SemanticSearchRegeneratePost(cacheKey, forceRerun, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SemanticSearchApi - object-oriented interface
 * @export
 * @class SemanticSearchApi
 * @extends {BaseAPI}
 */
class SemanticSearchApi extends base_1.BaseAPI {
    /**
     * Get semantic search.  Values from semantic search.
     * @summary Async Cluster Relationships
     * @param {SemanticSearchApiAsyncClusterRelationshipsV1SemanticSearchClusterAsyncPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).asyncClusterRelationshipsV1SemanticSearchClusterAsyncPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search.  Values from semantic search.
     * @summary Async Semantic Search
     * @param {SemanticSearchApiAsyncSemanticSearchV1SemanticSearchClusterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    asyncSemanticSearchV1SemanticSearchClusterPost(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).asyncSemanticSearchV1SemanticSearchClusterPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search.  Values from semantic search.
     * @summary Fetch Cluster Response
     * @param {SemanticSearchApiFetchClusterResponseV1SemanticSearchClusterAsyncRunIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).fetchClusterResponseV1SemanticSearchClusterAsyncRunIdGet(requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search.  Values from semantic search. Logs freemium usage on success
     * @summary Fetch Synthesis
     * @param {SemanticSearchApiFetchSynthesisV1SemanticSearchFetchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    fetchSynthesisV1SemanticSearchFetchGet(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).fetchSynthesisV1SemanticSearchFetchGet(requestParameters.cacheKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search usage.  date defaults to Jan 1st 2023 - before releasing tracking. Ommiting the date query param is equivalent of getting usage regardless of the date  metric defaults to Metrics.semantic_search_create for backward compatibility so that API consumers that don\'t pass a metric query param still get the original behaviour.
     * @summary Get Semantic Search Usage
     * @param {SemanticSearchApiGetSemanticSearchUsageV1SemanticSearchUsageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    getSemanticSearchUsageV1SemanticSearchUsageGet(requestParameters = {}, options) {
        return exports.SemanticSearchApiFp(this.configuration).getSemanticSearchUsageV1SemanticSearchUsageGet(requestParameters.dateFrom, requestParameters.metric, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search findings.  Values from semantic search.
     * @summary Get System Search Findings Data
     * @param {SemanticSearchApiGetSystemSearchFindingsDataV1SemanticSearchDataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    getSystemSearchFindingsDataV1SemanticSearchDataPost(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).getSystemSearchFindingsDataV1SemanticSearchDataPost(requestParameters.systemSearchIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get semantic search.  Values from semantic search.
     * @summary Regenerate Synthesis
     * @param {SemanticSearchApiRegenerateSynthesisV1SemanticSearchRegeneratePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    regenerateSynthesisV1SemanticSearchRegeneratePost(requestParameters, options) {
        return exports.SemanticSearchApiFp(this.configuration).regenerateSynthesisV1SemanticSearchRegeneratePost(requestParameters.cacheKey, requestParameters.forceRerun, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SemanticSearchApi = SemanticSearchApi;
/**
 * SsoApi - axios parameter creator
 * @export
 */
exports.SsoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviderNameV1IdpNameEmailGet: (email, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('getIdentityProviderNameV1IdpNameEmailGet', 'email', email);
            const localVarPath = `/v1/idp_name/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SsoApi - functional programming interface
 * @export
 */
exports.SsoApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SsoApiAxiosParamCreator(configuration);
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviderNameV1IdpNameEmailGet(email, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIdentityProviderNameV1IdpNameEmailGet(email, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * SsoApi - factory interface
 * @export
 */
exports.SsoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SsoApiFp(configuration);
    return {
        /**
         * Get Identity Provider name for given email domain.
         * @summary Get Identity Provider Name
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviderNameV1IdpNameEmailGet(email, options) {
            return localVarFp.getIdentityProviderNameV1IdpNameEmailGet(email, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SsoApi - object-oriented interface
 * @export
 * @class SsoApi
 * @extends {BaseAPI}
 */
class SsoApi extends base_1.BaseAPI {
    /**
     * Get Identity Provider name for given email domain.
     * @summary Get Identity Provider Name
     * @param {SsoApiGetIdentityProviderNameV1IdpNameEmailGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    getIdentityProviderNameV1IdpNameEmailGet(requestParameters, options) {
        return exports.SsoApiFp(this.configuration).getIdentityProviderNameV1IdpNameEmailGet(requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SsoApi = SsoApi;
/**
 * StripeApi - axios parameter creator
 * @export
 */
exports.StripeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost: (subscriptionId, addSubscriptionSeatIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            common_1.assertParamExists('addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost', 'subscriptionId', subscriptionId);
            // verify required parameter 'addSubscriptionSeatIn' is not null or undefined
            common_1.assertParamExists('addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost', 'addSubscriptionSeatIn', addSubscriptionSeatIn);
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(addSubscriptionSeatIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet: (subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            common_1.assertParamExists('getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSubscriptionV1StripeSubscriptionManagePost: (domainCallback, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/stripe/subscription-manage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (domainCallback !== undefined) {
                localVarQueryParameter['domain_callback'] = domainCallback;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete: (email, subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'email' is not null or undefined
            common_1.assertParamExists('removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete', 'email', email);
            // verify required parameter 'subscriptionId' is not null or undefined
            common_1.assertParamExists('removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/stripe/subscriptions/{subscription_id}/seats/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * StripeApi - functional programming interface
 * @export
 */
exports.StripeApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StripeApiAxiosParamCreator(configuration);
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * StripeApi - factory interface
 * @export
 */
exports.StripeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StripeApiFp(configuration);
    return {
        /**
         * Add subscription seats.
         * @summary Add Subscription Seats
         * @param {string} subscriptionId
         * @param {AddSubscriptionSeatIn} addSubscriptionSeatIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options) {
            return localVarFp.addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(subscriptionId, addSubscriptionSeatIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get subscription seats.
         * @summary Get Subscription Seats
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options) {
            return localVarFp.getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start stripe checkout session.
         * @summary Manage Subscription
         * @param {string} [domainCallback]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options) {
            return localVarFp.manageSubscriptionV1StripeSubscriptionManagePost(domainCallback, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove subscription seat.
         * @summary Remove Subscription Seat
         * @param {string} email
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options) {
            return localVarFp.removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(email, subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
class StripeApi extends base_1.BaseAPI {
    /**
     * Add subscription seats.
     * @summary Add Subscription Seats
     * @param {StripeApiAddSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(requestParameters, options) {
        return exports.StripeApiFp(this.configuration).addSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsPost(requestParameters.subscriptionId, requestParameters.addSubscriptionSeatIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get subscription seats.
     * @summary Get Subscription Seats
     * @param {StripeApiGetSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(requestParameters, options) {
        return exports.StripeApiFp(this.configuration).getSubscriptionSeatsV1StripeSubscriptionsSubscriptionIdSeatsGet(requestParameters.subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Start stripe checkout session.
     * @summary Manage Subscription
     * @param {StripeApiManageSubscriptionV1StripeSubscriptionManagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    manageSubscriptionV1StripeSubscriptionManagePost(requestParameters = {}, options) {
        return exports.StripeApiFp(this.configuration).manageSubscriptionV1StripeSubscriptionManagePost(requestParameters.domainCallback, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove subscription seat.
     * @summary Remove Subscription Seat
     * @param {StripeApiRemoveSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(requestParameters, options) {
        return exports.StripeApiFp(this.configuration).removeSubscriptionSeatV1StripeSubscriptionsSubscriptionIdSeatsEmailDelete(requestParameters.email, requestParameters.subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StripeApi = StripeApi;
/**
 * StudyMetadataApi - axios parameter creator
 * @export
 */
exports.StudyMetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost: (studyMetadataIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'studyMetadataIn' is not null or undefined
            common_1.assertParamExists('getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost', 'studyMetadataIn', studyMetadataIn);
            const localVarPath = `/v1/study-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(studyMetadataIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost: (studyMetadataIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'studyMetadataIn' is not null or undefined
            common_1.assertParamExists('getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost', 'studyMetadataIn', studyMetadataIn);
            const localVarPath = `/v1/study-metadata/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(studyMetadataIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * StudyMetadataApi - functional programming interface
 * @export
 */
exports.StudyMetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StudyMetadataApiAxiosParamCreator(configuration);
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * StudyMetadataApi - factory interface
 * @export
 */
exports.StudyMetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StudyMetadataApiFp(configuration);
    return {
        /**
         * Get study metadata from OpenAlex and DynamoDB via pmids.
         * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options) {
            return localVarFp.getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(studyMetadataIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get study metadata from SystemRDB via pmids.
         * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
         * @param {StudyMetadataIn} studyMetadataIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options) {
            return localVarFp.getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(studyMetadataIn, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StudyMetadataApi - object-oriented interface
 * @export
 * @class StudyMetadataApi
 * @extends {BaseAPI}
 */
class StudyMetadataApi extends base_1.BaseAPI {
    /**
     * Get study metadata from OpenAlex and DynamoDB via pmids.
     * @summary Get Study Metadata From Openalex For A Given List Of Pmids.
     * @param {StudyMetadataApiGetStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMetadataApi
     */
    getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(requestParameters, options) {
        return exports.StudyMetadataApiFp(this.configuration).getStudyMetadataFromOpenAlexForAGivenListOfPmidsV1StudyMetadataPost(requestParameters.studyMetadataIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get study metadata from SystemRDB via pmids.
     * @summary Get Study Metadata From Systemrdb For A Given List Of Pmids.
     * @param {StudyMetadataApiGetStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMetadataApi
     */
    getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(requestParameters, options) {
        return exports.StudyMetadataApiFp(this.configuration).getStudyMetadataFromSystemRDBForAGivenListOfPmidsV1StudyMetadataNewPost(requestParameters.studyMetadataIn, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StudyMetadataApi = StudyMetadataApi;
/**
 * SystemGraphApi - axios parameter creator
 * @export
 */
exports.SystemGraphApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownstreamEndpointV1SystemGraphPathsDownstreamGet: (node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'node' is not null or undefined
            common_1.assertParamExists('getDownstreamEndpointV1SystemGraphPathsDownstreamGet', 'node', node);
            const localVarPath = `/v1/system_graph/paths/downstream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }
            if (nHops !== undefined) {
                localVarQueryParameter['n_hops'] = nHops;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediatorsEndpointV1SystemGraphPathsMediatorsGet: (source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'source' is not null or undefined
            common_1.assertParamExists('getMediatorsEndpointV1SystemGraphPathsMediatorsGet', 'source', source);
            // verify required parameter 'target' is not null or undefined
            common_1.assertParamExists('getMediatorsEndpointV1SystemGraphPathsMediatorsGet', 'target', target);
            const localVarPath = `/v1/system_graph/paths/mediators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet: (topicId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'topicId' is not null or undefined
            common_1.assertParamExists('getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet', 'topicId', topicId);
            const localVarPath = `/v1/system_graph/topic/{topic_id}/one_degree`
                .replace(`{${"topic_id"}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipEndpointV1SystemGraphPathsRelationshipGet: (source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'source' is not null or undefined
            common_1.assertParamExists('getRelationshipEndpointV1SystemGraphPathsRelationshipGet', 'source', source);
            // verify required parameter 'target' is not null or undefined
            common_1.assertParamExists('getRelationshipEndpointV1SystemGraphPathsRelationshipGet', 'target', target);
            const localVarPath = `/v1/system_graph/paths/relationship`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphEndpointV1SystemGraphSemanticGraphGet: (topic1, topic2, ids1, ids2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/system_graph/semantic_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (topic1 !== undefined) {
                localVarQueryParameter['topic_1'] = topic1;
            }
            if (topic2 !== undefined) {
                localVarQueryParameter['topic_2'] = topic2;
            }
            if (ids1) {
                localVarQueryParameter['ids_1'] = ids1;
            }
            if (ids2) {
                localVarQueryParameter['ids_2'] = ids2;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet: (topicName, topicIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/system_graph/semantic_topic_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (topicName !== undefined) {
                localVarQueryParameter['topic_name'] = topicName;
            }
            if (topicIds) {
                localVarQueryParameter['topic_ids'] = topicIds;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet: (source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'source' is not null or undefined
            common_1.assertParamExists('getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet', 'source', source);
            // verify required parameter 'target' is not null or undefined
            common_1.assertParamExists('getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet', 'target', target);
            const localVarPath = `/v1/system_graph/paths/shared-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet: (source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'source' is not null or undefined
            common_1.assertParamExists('getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet', 'source', source);
            // verify required parameter 'target' is not null or undefined
            common_1.assertParamExists('getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet', 'target', target);
            const localVarPath = `/v1/system_graph/paths/shared-targets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemGraphEndpointV1SystemGraphSystemGraphGet: (numRelationships, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/system_graph/system_graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (numRelationships !== undefined) {
                localVarQueryParameter['num_relationships'] = numRelationships;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet: (topic1, ids1, topic2, ids2, pageSize, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'topic1' is not null or undefined
            common_1.assertParamExists('getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet', 'topic1', topic1);
            // verify required parameter 'ids1' is not null or undefined
            common_1.assertParamExists('getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet', 'ids1', ids1);
            const localVarPath = `/v1/system_graph/topological_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (topic1 !== undefined) {
                localVarQueryParameter['topic_1'] = topic1;
            }
            if (topic2 !== undefined) {
                localVarQueryParameter['topic_2'] = topic2;
            }
            if (ids1) {
                localVarQueryParameter['ids_1'] = ids1;
            }
            if (ids2) {
                localVarQueryParameter['ids_2'] = ids2;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpstreamEndpointV1SystemGraphPathsUpstreamGet: (node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'node' is not null or undefined
            common_1.assertParamExists('getUpstreamEndpointV1SystemGraphPathsUpstreamGet', 'node', node);
            const localVarPath = `/v1/system_graph/paths/upstream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }
            if (nHops !== undefined) {
                localVarQueryParameter['n_hops'] = nHops;
            }
            if (relationshipTypes !== undefined) {
                localVarQueryParameter['relationship_types'] = relationshipTypes;
            }
            if (includeNonSignificant !== undefined) {
                localVarQueryParameter['include_non_significant'] = includeNonSignificant;
            }
            if (semanticTypes !== undefined) {
                localVarQueryParameter['semantic_types'] = semanticTypes;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SystemGraphApi - functional programming interface
 * @export
 */
exports.SystemGraphApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SystemGraphApiAxiosParamCreator(configuration);
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * SystemGraphApi - factory interface
 * @export
 */
exports.SystemGraphApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SystemGraphApiFp(configuration);
    return {
        /**
         * Get downstream paths.
         * @summary Get Downstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getDownstreamEndpointV1SystemGraphPathsDownstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Mediators Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getMediatorsEndpointV1SystemGraphPathsMediatorsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system graph from the database.
         * @summary Get One Degree From Topic
         * @param {string} topicId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options) {
            return localVarFp.getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(topicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Relationship Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getRelationshipEndpointV1SystemGraphPathsRelationshipGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch semantic graph.
         * @summary Get Semantic Graph Endpoint
         * @param {string} [topic1] Topic 1
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids1] Topic 1 ids
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options) {
            return localVarFp.getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(topic1, topic2, ids1, ids2, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch single topic semantic graph.
         * @summary Get Semantic Topic Graph Endpoint
         * @param {string} [topicName] Topic name
         * @param {Array<string>} [topicIds] Topic ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options) {
            return localVarFp.getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(topicName, topicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Shared Sources Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get relationship path.
         * @summary Get Shared Targets Endpoint
         * @param {string} source System ID of source
         * @param {string} target System ID of target
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(source, target, page, pageSize, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system graph from the database.
         * @summary Get System Graph Endpoint
         * @param {number} [numRelationships] Number of relationships to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options) {
            return localVarFp.getSystemGraphEndpointV1SystemGraphSystemGraphGet(numRelationships, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch semantic graph.
         * @summary Get Topological Categories Endpoint
         * @param {string} topic1 Topic 1
         * @param {Array<string>} ids1 Topic 1 ids
         * @param {string} [topic2] Topic 2
         * @param {Array<string>} [ids2] Topic 2 ids
         * @param {number} [pageSize] Page size
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options) {
            return localVarFp.getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(topic1, ids1, topic2, ids2, pageSize, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upstream paths.
         * @summary Get Upstream Endpoint
         * @param {string} node System ID of topic node
         * @param {number} [page] Page number
         * @param {number} [pageSize] Page size
         * @param {number} [nHops] Number of hops
         * @param {string} [relationshipTypes] Comma separated list of relationship types
         * @param {boolean} [includeNonSignificant] Significant relationships only
         * @param {string} [semanticTypes] Comma separated list of semantic_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options) {
            return localVarFp.getUpstreamEndpointV1SystemGraphPathsUpstreamGet(node, page, pageSize, nHops, relationshipTypes, includeNonSignificant, semanticTypes, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SystemGraphApi - object-oriented interface
 * @export
 * @class SystemGraphApi
 * @extends {BaseAPI}
 */
class SystemGraphApi extends base_1.BaseAPI {
    /**
     * Get downstream paths.
     * @summary Get Downstream Endpoint
     * @param {SystemGraphApiGetDownstreamEndpointV1SystemGraphPathsDownstreamGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getDownstreamEndpointV1SystemGraphPathsDownstreamGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getDownstreamEndpointV1SystemGraphPathsDownstreamGet(requestParameters.node, requestParameters.page, requestParameters.pageSize, requestParameters.nHops, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get relationship path.
     * @summary Get Mediators Endpoint
     * @param {SystemGraphApiGetMediatorsEndpointV1SystemGraphPathsMediatorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getMediatorsEndpointV1SystemGraphPathsMediatorsGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getMediatorsEndpointV1SystemGraphPathsMediatorsGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get system graph from the database.
     * @summary Get One Degree From Topic
     * @param {SystemGraphApiGetOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getOneDegreeFromTopicV1SystemGraphTopicTopicIdOneDegreeGet(requestParameters.topicId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get relationship path.
     * @summary Get Relationship Endpoint
     * @param {SystemGraphApiGetRelationshipEndpointV1SystemGraphPathsRelationshipGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getRelationshipEndpointV1SystemGraphPathsRelationshipGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getRelationshipEndpointV1SystemGraphPathsRelationshipGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch semantic graph.
     * @summary Get Semantic Graph Endpoint
     * @param {SystemGraphApiGetSemanticGraphEndpointV1SystemGraphSemanticGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(requestParameters = {}, options) {
        return exports.SystemGraphApiFp(this.configuration).getSemanticGraphEndpointV1SystemGraphSemanticGraphGet(requestParameters.topic1, requestParameters.topic2, requestParameters.ids1, requestParameters.ids2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch single topic semantic graph.
     * @summary Get Semantic Topic Graph Endpoint
     * @param {SystemGraphApiGetSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(requestParameters = {}, options) {
        return exports.SystemGraphApiFp(this.configuration).getSemanticTopicGraphEndpointV1SystemGraphSemanticTopicGraphGet(requestParameters.topicName, requestParameters.topicIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get relationship path.
     * @summary Get Shared Sources Endpoint
     * @param {SystemGraphApiGetSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getSharedSourcesEndpointV1SystemGraphPathsSharedSourcesGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get relationship path.
     * @summary Get Shared Targets Endpoint
     * @param {SystemGraphApiGetSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getSharedTargetsEndpointV1SystemGraphPathsSharedTargetsGet(requestParameters.source, requestParameters.target, requestParameters.page, requestParameters.pageSize, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get system graph from the database.
     * @summary Get System Graph Endpoint
     * @param {SystemGraphApiGetSystemGraphEndpointV1SystemGraphSystemGraphGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getSystemGraphEndpointV1SystemGraphSystemGraphGet(requestParameters = {}, options) {
        return exports.SystemGraphApiFp(this.configuration).getSystemGraphEndpointV1SystemGraphSystemGraphGet(requestParameters.numRelationships, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch semantic graph.
     * @summary Get Topological Categories Endpoint
     * @param {SystemGraphApiGetTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getTopologicalCategoriesEndpointV1SystemGraphTopologicalCategoriesGet(requestParameters.topic1, requestParameters.ids1, requestParameters.topic2, requestParameters.ids2, requestParameters.pageSize, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get upstream paths.
     * @summary Get Upstream Endpoint
     * @param {SystemGraphApiGetUpstreamEndpointV1SystemGraphPathsUpstreamGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemGraphApi
     */
    getUpstreamEndpointV1SystemGraphPathsUpstreamGet(requestParameters, options) {
        return exports.SystemGraphApiFp(this.configuration).getUpstreamEndpointV1SystemGraphPathsUpstreamGet(requestParameters.node, requestParameters.page, requestParameters.pageSize, requestParameters.nHops, requestParameters.relationshipTypes, requestParameters.includeNonSignificant, requestParameters.semanticTypes, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SystemGraphApi = SystemGraphApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
exports.UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserByCognitoIdV1UsersPost: (userId, updateProfileIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('createAUserByCognitoIdV1UsersPost', 'userId', userId);
            // verify required parameter 'updateProfileIn' is not null or undefined
            common_1.assertParamExists('createAUserByCognitoIdV1UsersPost', 'updateProfileIn', updateProfileIn);
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateProfileIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserFromCredentialsV1UserPost: (userProfileIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userProfileIn' is not null or undefined
            common_1.assertParamExists('createAUserFromCredentialsV1UserPost', 'userProfileIn', userProfileIn);
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userProfileIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUserV1UserGet: (includeAvatar, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId
         * @param {boolean} [includeAvatar]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UsersUserIdGet: (userId, includeAvatar, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('getUserV1UsersUserIdGet', 'userId', userId);
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId]
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersV1UsersGet: (teamId, email, includeAvatar, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (includeAvatar !== undefined) {
                localVarQueryParameter['include_avatar'] = includeAvatar;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAUserByIdV1UsersUserIdPatch: (userId, updateProfileIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            common_1.assertParamExists('updateAUserByIdV1UsersUserIdPatch', 'userId', userId);
            // verify required parameter 'updateProfileIn' is not null or undefined
            common_1.assertParamExists('updateAUserByIdV1UsersUserIdPatch', 'updateProfileIn', updateProfileIn);
            const localVarPath = `/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateProfileIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthenticatedUserProfileV1UserPut: (userProfileIn, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userProfileIn' is not null or undefined
            common_1.assertParamExists('updateAuthenticatedUserProfileV1UserPut', 'userProfileIn', userProfileIn);
            const localVarPath = `/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication APIKeyHeader required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            yield common_1.setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(userProfileIn, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
exports.UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserFromCredentialsV1UserPost(userProfileIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAUserFromCredentialsV1UserPost(userProfileIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUserV1UserGet(includeAvatar, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAuthenticatedUserV1UserGet(includeAvatar, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId
         * @param {boolean} [includeAvatar]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UsersUserIdGet(userId, includeAvatar, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserV1UsersUserIdGet(userId, includeAvatar, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId]
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersV1UsersGet(teamId, email, includeAvatar, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersV1UsersGet(teamId, email, includeAvatar, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthenticatedUserProfileV1UserPut(userProfileIn, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAuthenticatedUserProfileV1UserPut(userProfileIn, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
exports.UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UsersApiFp(configuration);
    return {
        /**
         * Create a new user.
         * @summary Create A User By Cognito Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options) {
            return localVarFp.createAUserByCognitoIdV1UsersPost(userId, updateProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create A User From Credentials.
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAUserFromCredentialsV1UserPost(userProfileIn, options) {
            return localVarFp.createAUserFromCredentialsV1UserPost(userProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the authenticated user\'s profile.
         * @summary Get Authenticated User
         * @param {boolean} [includeAvatar] Include the user\&#39;s avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUserV1UserGet(includeAvatar, options) {
            return localVarFp.getAuthenticatedUserV1UserGet(includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single user\'s public profile.
         * @summary Get User
         * @param {string} userId
         * @param {boolean} [includeAvatar]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UsersUserIdGet(userId, includeAvatar, options) {
            return localVarFp.getUserV1UsersUserIdGet(userId, includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * List public profiles.
         * @summary Get Users
         * @param {string} [teamId]
         * @param {string} [email] Email address
         * @param {boolean} [includeAvatar] Include avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersV1UsersGet(teamId, email, includeAvatar, options) {
            return localVarFp.getUsersV1UsersGet(teamId, email, includeAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Update A User By Id.
         * @param {string} userId
         * @param {UpdateProfileIn} updateProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options) {
            return localVarFp.updateAUserByIdV1UsersUserIdPatch(userId, updateProfileIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user\'s profile.
         * @summary Update Authenticated User Profile
         * @param {UserProfileIn} userProfileIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthenticatedUserProfileV1UserPut(userProfileIn, options) {
            return localVarFp.updateAuthenticatedUserProfileV1UserPut(userProfileIn, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Create a new user.
     * @summary Create A User By Cognito Id.
     * @param {UsersApiCreateAUserByCognitoIdV1UsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createAUserByCognitoIdV1UsersPost(requestParameters, options) {
        return exports.UsersApiFp(this.configuration).createAUserByCognitoIdV1UsersPost(requestParameters.userId, requestParameters.updateProfileIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user.
     * @summary Create A User From Credentials.
     * @param {UsersApiCreateAUserFromCredentialsV1UserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createAUserFromCredentialsV1UserPost(requestParameters, options) {
        return exports.UsersApiFp(this.configuration).createAUserFromCredentialsV1UserPost(requestParameters.userProfileIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the authenticated user\'s profile.
     * @summary Get Authenticated User
     * @param {UsersApiGetAuthenticatedUserV1UserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAuthenticatedUserV1UserGet(requestParameters = {}, options) {
        return exports.UsersApiFp(this.configuration).getAuthenticatedUserV1UserGet(requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a single user\'s public profile.
     * @summary Get User
     * @param {UsersApiGetUserV1UsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserV1UsersUserIdGet(requestParameters, options) {
        return exports.UsersApiFp(this.configuration).getUserV1UsersUserIdGet(requestParameters.userId, requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List public profiles.
     * @summary Get Users
     * @param {UsersApiGetUsersV1UsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersV1UsersGet(requestParameters = {}, options) {
        return exports.UsersApiFp(this.configuration).getUsersV1UsersGet(requestParameters.teamId, requestParameters.email, requestParameters.includeAvatar, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user.
     * @summary Update A User By Id.
     * @param {UsersApiUpdateAUserByIdV1UsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateAUserByIdV1UsersUserIdPatch(requestParameters, options) {
        return exports.UsersApiFp(this.configuration).updateAUserByIdV1UsersUserIdPatch(requestParameters.userId, requestParameters.updateProfileIn, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the authenticated user\'s profile.
     * @summary Update Authenticated User Profile
     * @param {UsersApiUpdateAuthenticatedUserProfileV1UserPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateAuthenticatedUserProfileV1UserPut(requestParameters, options) {
        return exports.UsersApiFp(this.configuration).updateAuthenticatedUserProfileV1UserPut(requestParameters.userProfileIn, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
